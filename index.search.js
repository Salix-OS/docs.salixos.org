var relearn_search_index = [
  {
    "breadcrumb": "Salix Documentation",
    "content": "Got a question about Salix? You’re not alone. This FAQ section answers some of the most common questions we receive from users, covering everything from basic concepts to troubleshooting and more. Browse through the questions and answers below to see if we’ve already addressed your concern.\nCan I Use Third Party Repositories? How to Enable the root User How to Get an Extra Console in the Salix Installer Is Flatpak Available in Salix? How Do I Change the Default System Hostname? Icons Missing in the Xfce Menu How Do I Install a txz/tgz File I Found Online? How to Install the Kernel Source How to Play Multimedia Files Package Manager Wants to Downgrade Packages How to Get Notifications for Package Updates Packages that are Different from Slackware How to Read the Salix Man Page SalixLive Passwords Can I Use slackpkg in Salix? How Much Disk Space Does Salix Need How Do I Upgrade to Xfce 4.18? How Do I Upgrade to Xfce 4.20? Why Was Salix Created? ",
    "description": "Got a question about Salix? You’re not alone. This FAQ section answers some of the most common questions we receive from users, covering everything from basic concepts to troubleshooting and more. Browse through the questions and answers below to see if we’ve already addressed your concern.\nCan I Use Third Party Repositories? How to Enable the root User How to Get an Extra Console in the Salix Installer Is Flatpak Available in Salix?",
    "tags": [],
    "title": "Frequently Asked Questions",
    "uri": "/faq/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "What is gconf? GConf is a configuration scheme currently used by the GNOME desktop. Programs which use it setup default values in a $NAME.schemasfile which is installed under /etc/gconf/schemas/$NAME.schemas. These defaults are then registered with the gconf daemon which monitors the configuration values and alerts applications when values the applications are interested in change. The schema files also provide documentation about what each value in the configuration system means (which gets displayed when you browse the database in the gconf-editor program).\nFor packaging purposes, we have to disable schema installation during build, or these will get installed in the packager’s system instead of put in the package itself. They can then be created and placed in the package manually.\nDisabling schemas installation When a package requires the installation of gconf schemas, there is usually a --disable-schemas-install configure option that can be used to not let the makefile install any schemas to the system. You can check if the configure script provides such an option with configure --help.\nSometimes the configure script accepts a --with-gconf-source option. This should be used together with --disable-schemas-install like this, in order to set where and how the app should store its settings in gconf:\n./configure other_configure_options --disable-schemas-install --with-gconf-source=\"xml::/etc/gconf/gconf.xml.defaults\"However, the --disable-schemas-install option might not be working properly, or it might not even be available. In that case a GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL variable must be declared when running make install, like this:\nGCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL=1 make install DESTDIR=$startdir/pkgwhere $startdir/pkg is your packaging directory (as used by SLKBUILD).\nBe careful not to do:\nexport GCONF_DISABLE_MAKEFILE_SCHEMA_INSTALL=1at any point in your buildscript as pointed in some other sites about using gconf in other distributions, because the setting will stick and you won’t be allowed to install the schemas manually later on in your buildscript.\nInstalling schemas in the package Files with the .schemas extension will be created under the $startdir/pkg directory after running make install as specified above. Now, we need to manually register those schemas within the packaging directory. This can be achieved by putting something like this in your buildscript somewhere after the make install line:\n# gconf stuff export GCONF_CONFIG_SOURCE=\"xml::$startdir/pkg/etc/gconf/gconf.xml.defaults\"\\ if [ -d $startdir/pkg/etc/gconf/schemas ]; then\\ install -v -d -m755 $startdir/pkg/etc/gconf/gconf.xml.defaults\\ SCHEMAS=$startdir/pkg/etc/gconf/schemas\\ for schema in $SCHEMAS/*.schemas; do\\ gconftool-2 --makefile-install-rule $schema\\ done\\ # Reset / Verify correct permissions\\ ( cd $startdir/pkg/etc/gconf ; find . -type d -exec chmod 755 {} \\; )\\ ( cd $startdir/pkg/etc/gconf ; find . -type f -exec chmod 644 {} \\; )\\ fiwhere, as before, $startdir/pkg is your packaging directory. This will register any .schemas files present in $startdir/pkg/etc/gconf/schemas and put their default settings inside the package.\nSLKBUILD and gconf schemas files If you are using SLKBUILD to create your packages, the default behaviour is to make every file under /etc a .new file automatically. A .new file does not replace any older versions of the same file, this happens only after the user explicitly allows it to overwrite the older (already installed by a previous version of the package) file. While this is the recommended setting for most settings files that are placed in /etc, this is not the case for gconf settings files. Gconf settings files, just provide reasonable defaults for applications, which are tweaked, in an automated way, inside the users home directory. New gconf settings files should always replace previously installed files, because in many cases, they include changes that are necessary for the newer version of the software to work properly.\nSo, when you are installing gconf schemas in your package, make sure you add the noautodotnew option in your SLKBUILD:\noptions=('noautodotnew')and add any other files that you want to be .new’d in the dotnew=() array (see the SLKBUILD manpage for details)",
    "description": "What is gconf? GConf is a configuration scheme currently used by the GNOME desktop. Programs which use it setup default values in a $NAME.schemasfile which is installed under /etc/gconf/schemas/$NAME.schemas. These defaults are then registered with the gconf daemon which monitors the configuration values and alerts applications when values the applications are interested in change. The schema files also provide documentation about what each value in the configuration system means (which gets displayed when you browse the database in the gconf-editor program).",
    "tags": [],
    "title": "GConf and Packaging",
    "uri": "/dev/packaging/gconf/"
  },
  {
    "breadcrumb": "",
    "content": "Welcome to the Salix Documentation project! This is the place for tutorials, guides and frequently asked questions for both Salix users and developers.\nYou can navigate the documentation through the menubar, or search for a term using the sidebar.\nDocumentation is generally split into three sections:\nFrequently Asked Questions User Documentation Developer Documentation You can navigate the documentation or use the search bar for looking up specific terms. Note that the search function requires Javascript.\nIf you can’t find what you’re looking for, or have a suggestion for new content, please don’t hesitate to reach out in our forums, IRC channel or the mailing list.\nIf you would like to edit existing documentation or add new articles, you can do it by forking the git repository at Github and making a pull request. We’re constantly updating and improving the documentation, and your feedback is invaluable in helping us make it more comprehensive and user-friendly. Happy reading!\nTip In addition to this documentation, the Salix Startup Guide is also available to guide you with your first steps with Salix.",
    "description": "Welcome to the Salix Documentation project! This is the place for tutorials, guides and frequently asked questions for both Salix users and developers.\nYou can navigate the documentation through the menubar, or search for a term using the sidebar.\nDocumentation is generally split into three sections:\nFrequently Asked Questions User Documentation Developer Documentation You can navigate the documentation or use the search bar for looking up specific terms. Note that the search function requires Javascript.",
    "tags": [],
    "title": "Salix Documentation",
    "uri": "/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Upgrading to a new Salix release is a straightforward process, and we’ve put together a series of tutorials to guide you through it. Below, you’ll find step-by-step instructions on how to upgrade from one Salix release to the next. Please note that only upgrading to the next consecutive release is officially supported, so it’s recommended to upgrade in sequence rather than skipping releases. Attempting to upgrade multiple releases at once is not recommended and may lead to unexpected issues.\nHow to Upgrade Salix 14.2 to 15.0 How to Upgrade Salix 14.1 to 14.2 How to Upgrade Salix 14.0 to 14.1 How to Upgrade Salix 13.37 to 14.0 How to Upgrade Salix 13.1 to 13.37 How to Upgrade Salix 13.0 to 13.1 ",
    "description": "Upgrading to a new Salix release is a straightforward process, and we’ve put together a series of tutorials to guide you through it. Below, you’ll find step-by-step instructions on how to upgrade from one Salix release to the next. Please note that only upgrading to the next consecutive release is officially supported, so it’s recommended to upgrade in sequence rather than skipping releases. Attempting to upgrade multiple releases at once is not recommended and may lead to unexpected issues.",
    "tags": [],
    "title": "Upgrading Between Releases",
    "uri": "/user/upgrading/"
  },
  {
    "breadcrumb": "Salix Documentation",
    "content": "Welcome to the documentation section for Salix users. This section is designed to help you get the most out of your Salix experience, with guides and tutorials on how to install, configure, and use Salix. Whether you’re new to Salix or just looking for help with a specific task, this is the place to look first for the information you need to get started.\nIn case you don’t find what you’re looking for here, you can always visit our forums or reach us in our IRC channel.\nHow to Access a Server Running in a VirtualBox Guest Bluetooth Boot Into Existing Installation on Hard Disk Using Installation CD How to Install b43 Firmware for Broadcom Wireless Cards How to Configure Your Own DNS Server With a Static IP How to Enable Horizontal Scrolling With a 3-Button Mouse Fix Unknown Filetypes in Browser Greek Polytonic on Openbox How to Beta Test How to Create a Video DVD from the CLI How to Install a Different Kernel Install Salix from a USB stick How to Install the Virtualbox Guest Additions in a Salix Guest Install Kernel From Current How to Install the Proprietary NVIDIA Driver How to Compile the Linux Kernel LILO How to Install Multilib How to Rebuild the Slackware Kernel How to Remove Unnecessary Xorg Packages Repository Mirrors Restore Fluxbox Menu How to Install Salix Live on a USB Key? How to Use Sbopkg with Salix How to Setup Alpine With a Gmail Account Setup Basic Firewall Slackbuilds in Salix Repositories How to Login with SSH Without a Password Start Your Window Manager from the Login Screen Menu How to Tune an SSD Upgrading Between Releases How to Access Host USB Devices in a Guest OS Running in VirtualBox PUEL How to Install Xorg on Salix Core ",
    "description": "Welcome to the documentation section for Salix users. This section is designed to help you get the most out of your Salix experience, with guides and tutorials on how to install, configure, and use Salix. Whether you’re new to Salix or just looking for help with a specific task, this is the place to look first for the information you need to get started.\nIn case you don’t find what you’re looking for here, you can always visit our forums or reach us in our IRC channel.",
    "tags": [],
    "title": "User Documentation",
    "uri": "/user/"
  },
  {
    "breadcrumb": "Salix Documentation",
    "content": "Welcome to the Documentation section for Salix developers and packagers. Whether you’re a seasoned developer or just starting out, this documentation is designed to provide you with the information and guidance you need to get the most out of Salix. Here, you’ll find guides, tutorials, and reference materials covering various aspects of Salix development and packaging, from getting started with the basics to advanced topics and best practices. Browse through our documentation to learn how to contribute to Salix, create and maintain packages, and optimize your workflow. If you’re looking for something specific, use the links below to navigate to the relevant section.\nHow to Create a Public Salix Mirror How to Internationalize Shell Scripts How to Work with Transifex How to Work with Sourceforge If you’re interested in packaging software for Salix, you may also want to explore our dedicated packaging section, which provides detailed information on creating and maintaining packages for Salix.",
    "description": "Welcome to the Documentation section for Salix developers and packagers. Whether you’re a seasoned developer or just starting out, this documentation is designed to provide you with the information and guidance you need to get the most out of Salix. Here, you’ll find guides, tutorials, and reference materials covering various aspects of Salix development and packaging, from getting started with the basics to advanced topics and best practices. Browse through our documentation to learn how to contribute to Salix, create and maintain packages, and optimize your workflow.",
    "tags": [],
    "title": "Developer Documentation",
    "uri": "/dev/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation",
    "content": "Welcome to the packaging section, where you’ll find everything you need to create and maintain your own software packages for Salix. Whether you’re looking to package software for personal use or to share with the wider Salix community, this section provides detailed guides, tutorials, and best practices to help you get started and ensure your packages meet the high standards of the Salix repository.\nGConf and Packaging Getting git or svn sources for use with slkbuild MATEConf Schemas and Packaging Installing Mimetypes with a Package Package Categories Packaging rules Building Packages with slkbuild Scrollkeeper and Packaging Submitting Packages UIDs and GIDs to use with slkbuild ",
    "description": "Welcome to the packaging section, where you’ll find everything you need to create and maintain your own software packages for Salix. Whether you’re looking to package software for personal use or to share with the wider Salix community, this section provides detailed guides, tutorials, and best practices to help you get started and ensure your packages meet the high standards of the Salix repository.\nGConf and Packaging Getting git or svn sources for use with slkbuild MATEConf Schemas and Packaging Installing Mimetypes with a Package Package Categories Packaging rules Building Packages with slkbuild Scrollkeeper and Packaging Submitting Packages UIDs and GIDs to use with slkbuild ",
    "tags": [],
    "title": "Packaging Documentation",
    "uri": "/dev/packaging/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "You may have a 3 buttons mouse with vertical scroll, but no physical horizontal scroll.\nHere is how to have horizontal scroll emulation using SHIFT + vertical scroll.\nInstallation First install those two packages from source:\nsudo slapt-get -i xbindkeys xautomation xbindkeys will be use to do an action of specific events (here shift + vertical scroll). xautomation will be use to generate the horizontal scroll events for X. Configuration Vertical scrolling is seen as two buttons by X, by default it’s button 4 and 5. (1 is left, 2 is right, 3 is middle) Horizontal scrolling is also seen as two __buttons’, 6 and 7 by default.\nSo the idea is, for each SHIFT + button 4, a button 6 event should be generated. The same for button 5 and 7.\nCreate the file ~/.xbindkeysrc.scm with the following content:\n; bind shift + vertical scroll to horizontal scroll events (xbindkey '(shift \"b:4\") \"xte 'mouseclick 6'\") (xbindkey '(shift \"b:5\") \"xte 'mouseclick 7'\")Then create the file ~/.config/autostart/xbindkeys.desktop with the following content:\n[Desktop Entry] Encoding=UTF-8 Version=1.0 Type=Application Name=xbindkeys Exec=xbindkeysThis will run xbindkeys on every desktop login. You can run xbindkeys directly to have it work right now.\nFirefox For this to work in Firefox too, you have to disable the action bound to shift+scroll which do back and forward action per default.\nGo to about:config, search the key mousewheel.with_shift.action and assign it the value -1.",
    "description": "You may have a 3 buttons mouse with vertical scroll, but no physical horizontal scroll.\nHere is how to have horizontal scroll emulation using SHIFT + vertical scroll.\nInstallation First install those two packages from source:\nsudo slapt-get -i xbindkeys xautomation xbindkeys will be use to do an action of specific events (here shift + vertical scroll). xautomation will be use to generate the horizontal scroll events for X. Configuration Vertical scrolling is seen as two buttons by X, by default it’s button 4 and 5.",
    "tags": [],
    "title": "How to Enable Horizontal Scrolling With a 3-Button Mouse",
    "uri": "/user/enable-horizontal-scrolling-3-button-mouse/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "Yes, of course you are free to add third party repositories (e.g. GSB, MSB, alienbob…) to slapt-get, however, there may be issues.\nIt is important to remember that Salix does handle package dependencies, however, only for Salix \u0026 the ‘special’ Slackware repositories included in Salix default configuration for gslapt/slapt-get; not for any other third parties for whom we couldn’t guarantee any sort of quality or compatibility control.\nOne is always free to direct gslapt/slapt-get to any third party package repositories. Keep in mind that third party repositories may not: handle dependencies, be of sufficient quality and may not be compatible with Salix. In such a case, you should ‘‘know what you are doing’’ because you may end up breaking your system.",
    "description": "Yes, of course you are free to add third party repositories (e.g. GSB, MSB, alienbob…) to slapt-get, however, there may be issues.\nIt is important to remember that Salix does handle package dependencies, however, only for Salix \u0026 the ‘special’ Slackware repositories included in Salix default configuration for gslapt/slapt-get; not for any other third parties for whom we couldn’t guarantee any sort of quality or compatibility control.\nOne is always free to direct gslapt/slapt-get to any third party package repositories.",
    "tags": [],
    "title": "Can I Use Third Party Repositories?",
    "uri": "/faq/3rd-party-repos/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "VirtualBox guests are usually set up with NAT networking. That way, there is no way to directly access a server running in a VirtualBox guest from the host system or from anywhere in the network. In order to do that, you’ll have to inform VirtualBox to forward packets from a host port to a port in the guest system. This guide will show you how to access an ssh server running in a VirtualBox guest, but the procedure is similar for any kind of server that you may want to run (ftp, apache http etc).\nFirst of all, here’s how to get a list of the Virtual Machines you have set up, including VM names and UUIDs:\nVBoxManage list vmsAssuming the ssh server is running on port 22 in the guest system and you want to forward port 2222 from the host machine to the VirtualBox guest, you’ll need to run:\nVBoxManage setextradata \u003cguestname\u003e \"VBoxInternal/Devices/pcnet/0/LUN#0/Config/ssh/HostPort\" 2222 VBoxManage setextradata \u003cguestname\u003e \"VBoxInternal/Devices/pcnet/0/LUN#0/Config/ssh/GuestPort\" 22 VBoxManage setextradata \u003cguestname\u003e \"VBoxInternal/Devices/pcnet/0/LUN#0/Config/ssh/Protocol\" TCPThe guestname needs to be in quotes if it has any spaces in it. You’ll need to shutdown the VM if it’s already running and start it again (a reboot won’t do). Then you’ll be able to access the VM using ssh from the host system with:\nssh -p 2222 username@localhostor by any other PC in the network, by replacing “localhost” with the host systems IP address or hostname/domain.\nYou can check the settings for any VM, by running:\nVBoxManage getextradata \u003cguestname\u003e enumerateIf you want to remove a setting, you just need to set it to no value, for example, to remove the GuestPort setting:\nVBoxManage setextradata \u003cguestname\u003e \"VBoxInternal/Devices/pcnet/0/LUN#0/Config/ssh/GuestPort\"",
    "description": "VirtualBox guests are usually set up with NAT networking. That way, there is no way to directly access a server running in a VirtualBox guest from the host system or from anywhere in the network. In order to do that, you’ll have to inform VirtualBox to forward packets from a host port to a port in the guest system. This guide will show you how to access an ssh server running in a VirtualBox guest, but the procedure is similar for any kind of server that you may want to run (ftp, apache http etc).",
    "tags": [],
    "title": "How to Access a Server Running in a VirtualBox Guest",
    "uri": "/user/access-server-in-virtualbox/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Installing firmware Bluetooth should be working out-of-the-box if you selected the FULL installation set. But if you didn’t choose FULL and you want to have your bluetooth hardware working you can install these packages:\nbluez bluez-firmware bluez-hcidumpusing the gslapt package manager\nBluetooth frontend Here it depends on the salix flavor you chose ( eg : if you have chose KDE you should be able to find the frontend to deal with the bluetooth ) But if you don’t have the program that deals with bluez or you dont see the bluetooth icon in the notification are then you should be installing :\nbluemana lightweight Bluetooth manager which can get the job done for you .",
    "description": "Installing firmware Bluetooth should be working out-of-the-box if you selected the FULL installation set. But if you didn’t choose FULL and you want to have your bluetooth hardware working you can install these packages:\nbluez bluez-firmware bluez-hcidumpusing the gslapt package manager\nBluetooth frontend Here it depends on the salix flavor you chose ( eg : if you have chose KDE you should be able to find the frontend to deal with the bluetooth ) But if you don’t have the program that deals with bluez or you dont see the bluetooth icon in the notification are then you should be installing :",
    "tags": [],
    "title": "Bluetooth",
    "uri": "/user/bluetooth/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "After installing Salix to hard disk my LILO or GRUB was broken. How can I boot into the installed system on the hard disk using Salix installation CD (not LiveCD)?\nPut the Salix installation CD into the drive, reboot and when prompt appears type this:\nhugesmp.s root=/dev/partition rdinit= rowhere partition stands for your partition number (ie. sda2; sdb1, etc.) where Salix was installed and yes there is a space between rdinit= and ro.",
    "description": "After installing Salix to hard disk my LILO or GRUB was broken. How can I boot into the installed system on the hard disk using Salix installation CD (not LiveCD)?\nPut the Salix installation CD into the drive, reboot and when prompt appears type this:\nhugesmp.s root=/dev/partition rdinit= rowhere partition stands for your partition number (ie. sda2; sdb1, etc.) where Salix was installed and yes there is a space between rdinit= and ro.",
    "tags": [],
    "title": "Boot Into Existing Installation on Hard Disk Using Installation CD",
    "uri": "/user/boot-into-existing-installation/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "The Broadcom wireless chip needs proprietary software (called “firmware”) that runs on the wireless chip itself to work properly. This firmware is copyrighted by Broadcom and must be extracted from Broadcom’s proprietary drivers. To get such firmware on your system, you must download the driver from a legal distribution point, extract it, and install it.\nhttp://linuxwireless.org/en/users/Drivers/b43\nHere is a short guide on how to create a b43(legacy) firmware package for your system.\nSupported devices First you need to find out which firmware you require for your device. You can use the lspci command to display the Chip-ID of the wireless card which can then be compared against the Supported devices list at http://linuxwireless.org.\nsudo lspci -vnn | grep 14e4 0001:01:01.0 Network controller [0280]: Broadcom Corporation BCM4318 [AirForce One 54g] 802.11g Wireless LAN Controller [14e4:4318] (rev 02)The Chip-ID from the example above is [14e4:4318], using this information you should discover this card requires the b43 (as opposed to b43legacy) kernel module using version 4.150.10.5 of the firmware.\nSalix 14.1 and newer With the addition of dependency resolution in Sourcery and slapt-src all you need to do is to installed the b43-firmware package. Sourcery /slapt-src will recognize the need to install the b43-fwcutter package and do it automatically for you.\nsudo slapt-src -u sudo slapt-src -i b43-firmwareThat’s it, now reboot\nSalix 14.0 First you need to install the b43-fwcutter package from the Slackbuid repository using slapt-src or it’s graphical equivalent, Sourcery. Then follow this by installing the b43-firmware package also available in the Slackbuild repository\nslapt-src -u slapt-src -i b43-fwcutter slapt-src -i b43-firmwareThat’s it, now reboot\nPost-installation Once the firmware has been installed you can load the b43 (or b43legacy) kernel module with the modprobe command. If the module doesn’t load automatically on startup then you may want to add the command to /etc/rc.d/rc.local.\nmodprobe b43If you have installed Broadcom’s Hybrid Linux Driver then you will need to unload the wl module first.\nmodprobe -r wlTo perminently blacklist the wl module use the following command. This way you can easily delete /etc/modprobe.d/blacklist-wl.conf to remove the blacklist at a later date.\necho \"blacklist wl\" \u003e /etc/modprobe.d/blacklist-wl.confTroubleshooting There may be times when your target system doesn’t have any access to the internet other than via a wireless connection which creates a “chicken and egg” situation when it comes to upgrading or changing the installed operating system.\nSince this situation has been raised on the forum many times here are a few helpful hints.\nThe firmware has no architecture so the packages can be created on either version of Salix (32bit or 64bit) and installed on the other version. The system you use to extract the firmware does not require a Broadcom wireless card to be connected to it. Solution A: Install Salix inside a virtual machine before installing to your hard drive so you can create the firmware package while you still have a working internet connection. Solution B: Use a Salix Live CD to create the firmware package on another system with a working internet connection. ",
    "description": "The Broadcom wireless chip needs proprietary software (called “firmware”) that runs on the wireless chip itself to work properly. This firmware is copyrighted by Broadcom and must be extracted from Broadcom’s proprietary drivers. To get such firmware on your system, you must download the driver from a legal distribution point, extract it, and install it.\nhttp://linuxwireless.org/en/users/Drivers/b43\nHere is a short guide on how to create a b43(legacy) firmware package for your system.",
    "tags": [],
    "title": "How to Install b43 Firmware for Broadcom Wireless Cards",
    "uri": "/user/broadcom/"
  },
  {
    "breadcrumb": "Salix Documentation",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "The easy way to do it, is to simply run the gtkhostsetup Salix system tool.\nOtherwise, you may follow the instructions below:\nIf you completed a FULL mode Salix installation, the default hostname is set to darkstar.example.net (inherited from Slackware). If you need to change the hostname you can edit the /etc/hosts and /etc/HOSTNAME files accordingly. For example:\n/etc/hosts:\n# # hosts # This file describes a number of hostname-to-address # mappings for the TCP/IP subsystem. It is mostly # used at boot time, when no name servers are running. # On small systems, this file can be used instead of a # \"named\" name server. Just add the names, addresses # and any aliases to this file... # # By the way, Arnt Gulbrandsen `\u003cagulbra@nvg.unit.no\u003e` says that 127.0.0.1 # should NEVER be named with the name of the machine. It causes problems # for some (stupid) programs, irc and reputedly talk. :^) # # For loopbacking. 127.0.0.1 localhost 127.0.0.1 mypc.salixos.org mypc # End of hosts/etc/HOSTNAME:\nmypc.salixos.org",
    "description": "The easy way to do it, is to simply run the gtkhostsetup Salix system tool.\nOtherwise, you may follow the instructions below:\nIf you completed a FULL mode Salix installation, the default hostname is set to darkstar.example.net (inherited from Slackware). If you need to change the hostname you can edit the /etc/hosts and /etc/HOSTNAME files accordingly. For example:\n/etc/hosts:\n# # hosts # This file describes a number of hostname-to-address # mappings for the TCP/IP subsystem.",
    "tags": [],
    "title": "How Do I Change the Default System Hostname?",
    "uri": "/faq/hostname/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Because a friend had to setup his own dns server using the static ip and installed the ubuntu on the server, so I set up the dns server. The instructions below are for any possible need to do the same. The domain here is my-domain.gr you replace it with your own.\nThe instructions are simple and not in the correct technical vocabulary to be understand from all. The following instructrions work and of course someone else may use different settings.\nIt is assumed that on the registrar, we maintain our domain name, we have created a nameserver e.g. ns0.my-domain.gr giving it a static ip x1.x2.x3.x4. We can define a second with the same static ip ns1.my-domain.gr Then in the domain name that we enshrine in the example my-domain.gr put as Domain Name Servers (nameservers) the ns0.my-domain.gr and ns1.my-domain.gr\nAnd also a few hours to 48 hours may need for the nameservers to be updated with the ip corresponding to our ns0.my-domain.gr. So if you change the nameservers of your domain, the transition to the new hosting server will be completed in about 3 to 48 hours, depending on the company that provides you connect the Internet. So making a dig from any pc you will not find the domain if you do not first the nameservers around the world updated.\nThe following we do in our own server if you run from home and have static ip or do after login to the server we have in such a company, using ssh. Here as an example we use the domain my-domain.gr. You put your own which you have first-register. The static ip is x1.x2.x3.x4. x1.x2.x3.x4 replace it with your static ip The ip of the company’s nameservers are k1.k2.k3.k4 m1.m2.m3.m4\nBelow where is x1, x2, x3, x4, K1, K2, K3, K4, m1, m2, m3, m4 will put the corresponding numbers.\n/etc/named.conf zone \"my-domain.gr.\" IN { type master; file \"/etc/bind/db.my-domain.gr\"; // for slackware \"/var/named/caching-example/db.my-domain.gr\" };` zone \"x4.x3.x2.in-addr.arpa\" { type master; file \"/etc/bind/rev.x4.x3.x2.in-addr.arpa\"; // for slackware \"/var/named/caching-example/rev.x4.x3.x2.in-addr. arpa \" };` options { directory \"/var/cache/bind\"; // for slackware directory \"/var/named\"; notify no; forward only; forwarders {k1.k2.k3.k4; m1.m2.m3.m4;}; // here we put our name servers that has given the company that runs the server. };`/etc/resolv.conf search my-domain.gr nameserver x1.x2.x3.x4 nameserver k1.k2.k3.k4 nameserver m1.m2.m3.m4/var/named/caching-example/db.my-domain.gr ; $ TTL 604800 @ IN SOA ns0.my-domain.gr. my-domain.gr. ( 2006081401 28800 3600 604800 38400 ) IN NS ns0 IN NS ns1 my-domain.gr. IN A x1.x2.x3.x4 my-domain.gr. IN MX 10 mail.my-domain.gr. ns0 IN A x1.x2.x3.x4 ns1 IN A x1.x2.x3.x4 www IN A x1.x2.x3.x4 mail IN A x1.x2.x3.x4/var/named/caching-example/rev.x4.x3.x2.in-addr.arpa $ TTL 1D @ IN SOA ns0.my-domain.gr. admin.my-domain.gr. ( 2006081401 ; 28800 ; 604800 ; 604800 ; 86400 ) IN NS ns0.my-domain.gr. x4 IN PTR my-domain.gr`x4 is the same as the last number of the static ip (x1.x2.x3.x4)\nTest the server /var/named/caching- example/rev.x4.x3.x2.in-addr.arpa\nOUTPUT: loading \"x4.x3.x2.in-addr.arpa\" from \"/etc/bind/rev.x4.x3.x2.in-addr.arpa\" class \"IN\" zone x4.x3.x2.in-addr.arpa/IN: loaded serial 2006081401 OK`/var/named/caching-example/db.my-domain.gr\nOUTPUT: loading \"my-domain.gr\" from \"/etc/bind/db.my-domain.gr\" class \"IN\" zone my-domain.gr/IN: loaded serial 2006081401 OK`restart the bind We restart the bind:\nsudo service restart bindThefollowing commands from the ssh shell should give us (instead of x1.x2.x3.x4 put the numbers of your static ip.\n$ nslookup my-domain.gr Server: 192.168.1.254 Address: 192.168.1.254 # 53 Non-authoritative answer: Name: my-domain.gr Address: x1.x2.x3.x4` $ nslookup www.my-domain.gr Server: 192.168.1.254 Address: 192.168.1.254 # 53 Non-authoritative answer: Name: www.my-domain.gr Address: x1.x2.x3.x4` $ nslookup mail.my-domain.gr Server: 192.168.1.254 Address: 192.168.1.254 # 53 Non-authoritative answer: Name: mail.my-domain.gr Address: x1.x2.x3.x4` $ dig www.my-domain.gr ; \u003c\u003c \u003e\u003e DiG 9.7.0-P1 \u003c\u003c \u003e\u003e www.my-domain.gr ;; Global options: + cmd ;; Got answer: ;; - \u003e\u003e HEADER \u003c\u003c - opcode: QUERY, status: NOERROR, id: 29213 ;; Flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 2 ;; QUESTION SECTION: ; Www.my-domain.gr. IN A ;; ANSWER SECTION: www.my-domain.gr. 604800 IN A x1.x2.x3.x4 ;; AUTHORITY SECTION: my-domain.gr. 604800 IN NS ns0.my-domain.gr. my-domain.gr. 604800 IN NS ns1.my-domain.gr. ;; ADDITIONAL SECTION: ns0.my-domain.gr. 604800 IN A x1.x2.x3.x4 ns1.my-domain.gr. 604800 IN A x1.x2.x3.x4 ;; Query time: 8 msec ;; SERVER: x1.x2.x3.x4 # 53 (x1.x2.x3.x4) ;; WHEN: Fri Jun 1 09:46:43 2012 ;; MSG SIZE rcvd: 120`",
    "description": "Because a friend had to setup his own dns server using the static ip and installed the ubuntu on the server, so I set up the dns server. The instructions below are for any possible need to do the same. The domain here is my-domain.gr you replace it with your own.\nThe instructions are simple and not in the correct technical vocabulary to be understand from all. The following instructrions work and of course someone else may use different settings.",
    "tags": [],
    "title": "How to Configure Your Own DNS Server With a Static IP",
    "uri": "/user/configure-own-dns-server/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "Since the 14.1 release the root user is disabled by default and the use of sudo is needed to perform administrative tasks. If you want to enable the root user, all you have to do is log in as a user that has sudo privileges (any user that is a member of the wheel group) and run the following command:\nsudo passwd rootand provide a new password for the root user. After that you will be able to run:\nsuto open a root user session.\nIf you want to have all graphical dialogs ask for the root password instead of the user password, you need to remove the gnsu package and install the ktsuss package.",
    "description": "Since the 14.1 release the root user is disabled by default and the use of sudo is needed to perform administrative tasks. If you want to enable the root user, all you have to do is log in as a user that has sudo privileges (any user that is a member of the wheel group) and run the following command:\nsudo passwd rootand provide a new password for the root user.",
    "tags": [],
    "title": "How to Enable the root User",
    "uri": "/faq/enable-root/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Symptom Sometimes when you download a file, you get prompted to open or save it (at least in Firefox in the default mode) and the only choice you get to open the file is not the right one (often a text editor). But sometimes it’s ok, for the same file type. Why?\nThe reason is that when it fails to propose the right choice, the file type is unknown to the browser. This is usually the server fault as it normally needs to send the correct file type in the header for the browser to propose the right solution.\nWhat can we do to fix it on the desktop side? Well, in Windows, the file extension could be used to guess the file type and propose the correct application to open it. It’s often not reliable, mainly if the file has no extension at all. In Linux world, the mimetype is used. This a database that checks inside the file for chunk of data to determine the mimetype/file type. And this is quite reliable. But there is a problem, the browser offer you to open the file…that it will download. So there is no way before downloading it for the browser to know and help you. The solution is to rely on xdg-open binary that read the mimetype of the file, the user default application for that mimetype and then open the file with it.\nSolution So let’s do open unknown file type with xdg-open. First, create a file named xdg-open in ~/.local/share/applications/ containing:\n[Destkop Entry] Type=Application Version=1.0 Name=xdg-open Exec=xdg-open %f Terminal=falseThen edit your ~/.local/share/applications/mimeapps.list file and modify any line containing application/octet-stream with:\napplication/octet-stream=xdg-open.desktopYou’re done!\nNow in Firefox, for example, the default application “xdg-open” is proposed and when hitting ok, it will download the file to a temporary location and open it with the right application.",
    "description": "Symptom Sometimes when you download a file, you get prompted to open or save it (at least in Firefox in the default mode) and the only choice you get to open the file is not the right one (often a text editor). But sometimes it’s ok, for the same file type. Why?\nThe reason is that when it fails to propose the right choice, the file type is unknown to the browser.",
    "tags": [],
    "title": "Fix Unknown Filetypes in Browser",
    "uri": "/user/fix-unknown-filetypes-in-browser/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "Flatpak is installed by default on Salix since version 15.0, no setup required!\nFlatpak comes preconfigured with the Flathub repository and desktop integration tools are included to allow 1-click install from Flathub. All you have to do is install some apps!",
    "description": "Flatpak is installed by default on Salix since version 15.0, no setup required!\nFlatpak comes preconfigured with the Flathub repository and desktop integration tools are included to allow 1-click install from Flathub. All you have to do is install some apps!",
    "tags": [],
    "title": "Is Flatpak Available in Salix?",
    "uri": "/faq/flatpak/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "If the source only exists in a git or svn repository, then you will have to create a source tarball yourselves and upload it somewhere. You have to add the created source tarballs to the source variable in the SLKBUILD file. Also make sure that you upload the source tarball to your sourcetemplate location. Example:\nsource=(\"http://some-domain.org/packages/xap/$pkgname/$pkgname-$pkgver.src.tar.gz\")git This script gets latest git sources, creates a source tarball named after the current date and updates the $pkgver variable in the SLKBUILD file.\n#!/bin/bash pkgname=amarok # set pkgver to current date pkgver=$(date +%Y%m%d) if [ -d $pkgname ]; then ( cd $pkgname git pull --depth 1 ) else git clone --depth 1 git://gitorious.org/amarok/amarok.git fi # create the source archive tar czf $pkgname-$pkgver.src.tar.gz amarok # change the SLKBUILD sed -i 's#^pkgver=.*#pkgver='$pkgver'#' SLKBUILDsvn This script gets latest svn sources, creates a source tarball named after the svn revision and updates the $pkgver variable in the SLKBUILD file. It also can retrieve a svn revision specified on command line:\n#!/bin/bash pkgname=taglib # retrieve revision given on command line - else latest revision svn_rev=${1:-\"\"} # svn url svn_dir=${pkgname} svn_url=svn://anonsvn.kde.org/home/kde/trunk/kdesupport/${svn_dir} # let's rock! svn_cmd=\" co\" # if revision is set by command line, then get this revision [ ! -z $svn_rev ] \u0026\u0026 svn_cmd=\"$svn_cmd -r $svn_rev\" # set pkgver to the downloaded revision cur_rev=$(svn $svn_cmd $svn_url $svn_dir 2\u003esvn_err.log | tail -1 |tr -c -d \"[:digit:]\") pkgver=\"r${cur_rev}\" # create the source archive tar czf $pkgname-$pkgver.src.tar.gz $svn_dir # change the SLKBUILD sed -i 's#^pkgver=.*#pkgver='$pkgver'#' SLKBUILD",
    "description": "If the source only exists in a git or svn repository, then you will have to create a source tarball yourselves and upload it somewhere. You have to add the created source tarballs to the source variable in the SLKBUILD file. Also make sure that you upload the source tarball to your sourcetemplate location. Example:\nsource=(\"http://some-domain.org/packages/xap/$pkgname/$pkgname-$pkgver.src.tar.gz\")git This script gets latest git sources, creates a source tarball named after the current date and updates the $pkgver variable in the SLKBUILD file.",
    "tags": [],
    "title": "Getting git or svn sources for use with slkbuild",
    "uri": "/dev/packaging/git-svn-sources-with-slkbuild/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Writing greek polytonic,monotonic and ancient, modern spell checking on LibreOffice and Openbox.\nset the key Open the file ~/.config/openbox/rc.xml with a text editor. e.g. geany ~/.config/openbox/rc.xml\ngo to line 294 last row with /keybind and add the lines bellow\n\u003ckeybind key=\"C-1\"\u003e \u003caction name=\"Execute\"\u003e \u003ccommand\u003esh ~/.polytonic\u003c/command\u003e \u003cstartupnotify\u003e \u003cenabled\u003eyes\u003c/enabled\u003e \u003cname\u003ePolytonic/Monotonic\u003c/name\u003e \u003c/startupnotify\u003e \u003c/action\u003e \u003c/keybind\u003e Save the file\nCreate the polytonic file Create the file ~/.polytonic\ngeany ~/.polytonicand paste the lines\n#!/bin/sh # Dimitris Tzemos \u003cdjemos@slackel.gr\u003e # Αρχείο για αλλαγή μονοτονικού πολυτονικού πληκτρολογίου # για συγγραφή αρχαίων κειμένων # File to change from greek monotonic to greek polytonic keyboard # to type ancient greek documents. # check=$(setxkbmap -print | grep 'extended') if [ -z \"$check\" ];then setxkbmap us,el -variant ,extended zenity --info --timeout 1 --text 'Μονοτονικό πληκτρολόγιο ενεργό' 1 else setxkbmap us,el -variant ,polytonic zenity --info --timeout 1 --text 'Πολυτονικό πληκτρολόγιο ενεργό' 1 fi if [ -r /etc/X11/Xmodmap ];then xmodmap /etc/X11/Xmodmap;fi if [ -r \"$HOME\"/.Xmodmap ];then xmodmap \"$HOME\"/.Xmodmap;fiSave the file\nMessages Μονοτονικό πληκτρολόγιο ενεργό = Monotonic keyboard active Πολυτονικό πληκτρολόγιο ενεργό = Polytonic keyboard activeyou can change greek messages with english ones above if you like.\nNow every time you press Ctrl+1 change between monotonic to polytonic and polytonic to monotonic\nLibreoffice For greek spelling modern and/or ancient greek download these files and install them from libreoffice tools-\u003eextensions\nmodern greek http://sourceforge.net/projects/aoo-extensions/files/1411/2/el_gr_v110.oxt/download\nancient greek http://sourceforge.net/projects/aoo-extensions/files/2313/1/grc.oxt/download\nThats it!!! Now can write greek modern or polytonic in libreoffice and also have spell checking.\nTo write greek polytonic press alt-shift to change keyboard and then press ctrl+1 to go to polytonic.\nKeyboard typing for polytonic characters on LINUX ά= τόνος + γράμμα (γιὰ ὁξεῖα) ὰ=εἰσαγωγικά + γράμμα (γιὰ βαρεῖα) ἁ=shift+εἰσαγωγικά+γράμμα ἀ=shift+τόνος+γράμμα ᾶ=ἀγκύλη ἀριστερή+γράμμα ᾳ=ἀγκύλη δεξιά+γράμμα ᾷ+αγκύλη δεξιά+ἀγκύλη ἀριστερή + γράμμα ἆ=ἀγκύλη ἀριστερή+shift τόνος+γράμμα ἇ=ἀγκύλη ἀριστερή+shift εἰσαγωγικά ἄ=τόνος+shift τόνος+γράμμα ἅ=shift εἰσαγωγικά+τόνος+γράμμα ΐ=Alt Gr+τόνος σε μη πολυτονική γραμματοσειράAccents ; acute accent (ὀξεῖα) ' grave accent (βαρεῖα) [ circumflex (περισπωμένη);a ά 'a ὰ [a ᾶBreathing : smooth breathing (ψιλὸν πνεῦμα) \" rough breathing (δασὺ πνεῦμα):a ἀ \"a ἁDiaresis { diaresis (διαλυτικά) {i ϊCombining: Accent before breathing [:a ἆ ]:a ᾀ ][:a ᾆ ]\"a ᾀ [\"a ἆ ;:a ἄ '\"a ἃ ':a ἅ \":a ἂHere is some sample text:\nΜῆνιν ἄειδε θεὰ Πηληϊάδεω Ἀχιλῆος οὐλομένην, ἣ μυρί᾿ Ἀχαιοῖς ἄλγε᾿ ἔθηκε, πολλὰς δ᾿ ἰφθίμους ψυχὰς Ἄϊδι προΐαψεν ἡρώων, αὐτοὺς δὲ ἑλώρια τεῦχε κύνεσσιν οἰωνοῖσί τε πᾶσι· Διὸς δ᾿ ἐτελείετο βουλή, ἐξ οὗ δὴ τὰ πρῶτα διαστήτην ἐρίσαντε Ἀτρεΐδης τε ἄναξ ἀνδρῶν καὶ δῖος Ἀχιλλεύς. Ψάλλε θεά, τον τρομερό θυμόν του Αχιλλέως Πώς έγινε στους Αχαιούς αρχή πολλών δακρύων. Που ανδράγαθες ροβόλησε πολλές ψυχές στον Άδη ηρώων, κι έδωκεν αυτούς αρπάγματα των σκύλων και των ορνέων – και η βουλή γενόταν του Κρονίδη, απ’ ότ’, εφιλονίκησαν κι εχωρισθήκαν πρώτα ο Ατρείδης, άρχος των ανδρών, και ο θείος Αχιλλέας.",
    "description": "Writing greek polytonic,monotonic and ancient, modern spell checking on LibreOffice and Openbox.\nset the key Open the file ~/.config/openbox/rc.xml with a text editor. e.g. geany ~/.config/openbox/rc.xml\ngo to line 294 last row with /keybind and add the lines bellow\n\u003ckeybind key=\"C-1\"\u003e \u003caction name=\"Execute\"\u003e \u003ccommand\u003esh ~/.polytonic\u003c/command\u003e \u003cstartupnotify\u003e \u003cenabled\u003eyes\u003c/enabled\u003e \u003cname\u003ePolytonic/Monotonic\u003c/name\u003e \u003c/startupnotify\u003e \u003c/action\u003e \u003c/keybind\u003e Save the file\nCreate the polytonic file Create the file ~/.polytonic\ngeany ~/.polytonicand paste the lines\n#!/bin/sh # Dimitris Tzemos \u003cdjemos@slackel.",
    "tags": [],
    "title": "Greek Polytonic on Openbox",
    "uri": "/user/greek-polytonic-on-openbox/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Beta Testing and what’s involved… First Steps When the developers announce a new version of a distribution is available for testing, they really appreciate anyone who actually downloads and installs the beta version so that they can find any major bugs in the release.\nSo there is the first thing that is involved - download and install the release.\nWhat should be done if it doesn’t install properly, or has some sort of problem and won’t reboot after the install?\nReport it - please post your comments to the release annoucement in the forum, so everything is in one place. Read through the thread to see what others have discovered. Your feedback should be as detailed as you can make it - where it failed/hiccupped, how it recovered (or if it didn’t) and any information on what was happening on the screen. Some details of your setup could also be appropriate - whether it was a 32 or 64 bit version, if it was a virtual machine or a bare metal install, what type of install it was (core, basic or full), any workarounds you found and basically anything else you think might be important.\nRemember the aim is to give the developers information so that they can fix whatever is wrong for all the users (including you!).\nIf you get the release to install without problems, testing basic functionality can be really helpful.\nSecond Step For a core install, where no GUI is available, start programs from their own terminal(s) - this not only keeps them contained, but usually an application will happily spit out information to the terminal window that may be of great help to the developers if there are any problems. Even just checking that what you are wanting to run or use on a regular basis is a help.\nFor a basic or full install, note any GUI screen glitches (e.g. not having your maximum resolution available, any tearing or glitching of the graphics system, colours that you know are wrong etc.), any sub-systems that don’t/won’t start, any on-screen messages/windows from underlying software that are detailing problems, check networking is up and running, check internet connectivity - in short, check that the sub-systems are working as you would expect before running any applications, and note down anything that you think is wrong.\nIf nothing appears to be amiss, then start testing your usual aplications - testing each installed application is a real pain, especially if you don’t use them - but it all helps, even if you just check that they start from the menu(s). If you haven’t got the time, then just checking the ones you regularly use is still helpful.\nThird Step The single most important step in Beta Testing is…\nReport your results!\nIf it works as you expect, then let the developers know - say what you tested and what works.\nIf it doesn’t work as you expect, then let the developers know - say what you tested and what didn’t work, and put the notes you made earlier in the report.\nThe developers will thank you, and down the track the users will thank you, and the end result of this is a much pleasanter user experience for all.\nIf you really dig this stuff… For those of you who want a more proscribed approach, here are the steps I follow when I decide to beta test a new release.\nDownload the iso and generate and check the md5sum/SHA1. Note any area of particular concern to the developers that they would like tested.\nInstall to bare metal:\ncore check all sub-systems check my most used applications (I am most familiar with them and can note changes/problems quickly) check other important applications (important in the sense that a lot of people use them, or important in the sense that they have been upgraded in this release and need checking) prepare a report Repeat for 32bit basic and full with these added steps:\ncheck/install appropriate graphics drivers check basic desktop functionality - copy/paste, open/close, delete/trash etc. check my most used applications. work through the menu of applications as supplied with a view to checking that they all work. try any “distro specific” tools (codec installer, Sourcery or Gslapt for Salix) prepare a report Tip [REALITY CHECK] Generally, if it works in a core install, it will work in a basic or full install as it is the same package - where you may get problems is when it interacts with extra bits put in by a basic or full install. That is why I say to test it again in the later installs.\nRepeat all of the above for 64 bit.\nRepeat all of the above for virtual machine installs.\nSubmit your reports as you see fit, but sooner rather than later. Don’t forget to specifically mention any areas that the developers wanted tested and what you found for that particular area.\nRemember, Beta Testing is important, but it doesn’t have to be formal, proscribed or daunting. Just download, install and use, and report any problems - and if you don’t get any problems, report that too!",
    "description": "Beta Testing and what’s involved… First Steps When the developers announce a new version of a distribution is available for testing, they really appreciate anyone who actually downloads and installs the beta version so that they can find any major bugs in the release.\nSo there is the first thing that is involved - download and install the release.\nWhat should be done if it doesn’t install properly, or has some sort of problem and won’t reboot after the install?",
    "tags": [],
    "title": "How to Beta Test",
    "uri": "/user/how-to-beta-test/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation",
    "content": "These are rather generic instructions to create a public Salix mirror. You should be familiar with rsync and cron jobs to get things working. At first some basic things:\nIt’s up to you if you want to create a ftp or a http mirror Of course you have to adjust the output dirs, that are used in the rsync commands Syncing once a day may be a good idea Salix mirror Let’s get things started. If you want to sync the complete Salix repository you can just use:\nrsync -a --del slackware.org.uk::salix salixThat will create a “salix” directory with everything in the salix repository in it and you have to do nothing else. Just make sure that this command is run regularly, so your mirror is kept up to date.\nIf you want to only mirror some parts of the repository, you can still do that. For example if you only want to mirror the repositories for version 13.0, individually for the i486 and x86_64 repositories, you can do that with:\nrsync -a --del slackware.org.uk::salix/i486/13.0/ i486/13.0/ rsync -a --del slackware.org.uk::salix/x86_64/13.0/ x86_64/13.0/respectively.",
    "description": "These are rather generic instructions to create a public Salix mirror. You should be familiar with rsync and cron jobs to get things working. At first some basic things:\nIt’s up to you if you want to create a ftp or a http mirror Of course you have to adjust the output dirs, that are used in the rsync commands Syncing once a day may be a good idea Salix mirror Let’s get things started.",
    "tags": [],
    "title": "How to Create a Public Salix Mirror",
    "uri": "/dev/create-public-mirror/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "If you installed a new software package and the respective icons are missing from the Xfce menu, it’s because Xfce is too slow to update the icon caches. Just run the following command as to update the icon cache for all icon themes installed in your system (among other things):\nsudo update-allIf you have any icon themes installed in your home directory instead of having them installed systemwide, you probably need to run something like this (as non-priviliged user this time):\nfor i in ~/.icons/*;do gtk-update-icon-cache -f $i; done",
    "description": "If you installed a new software package and the respective icons are missing from the Xfce menu, it’s because Xfce is too slow to update the icon caches. Just run the following command as to update the icon cache for all icon themes installed in your system (among other things):\nsudo update-allIf you have any icon themes installed in your home directory instead of having them installed systemwide, you probably need to run something like this (as non-priviliged user this time):",
    "tags": [],
    "title": "Icons Missing in the Xfce Menu",
    "uri": "/faq/icons-missing-in-xfce/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "If you have hardware that is not supported by the kernel that ships with Salix, you can compile your own. In most cases though, it is sufficient to install the latest kernel from the repositories. This page contains instructions for this straightforward procedure, and also for installing the kernel manually. In some cases, if there is a regression, meaning hardware that used to be supported doesn’t work any more, you might actually need to downgrade to an older kernel, but in most cases the solution will be a more recent one. This is probably the first thing to try before embarking on building the kernel yourself, which can be quite time-consuming, though it is not really that difficult.\nIt is very important to reinstall the bootloader before you reboot, unless your bootloader is controlled by a Linux installation in another partition. # Installing directly from the repositories\nAs a general principle, you should stay with the same kernel series, for example, in Salix 14.2, the 4.4 series; it is preferable to install the latest one from the repositories, ensuring as described below that you include all needed packages, and update the bootloader (see “Final steps” below). This is also the most straightforward way of upgrading the kernel. For example:\nsudo slapt-get -i kernel-huge kernel-modules kernel-headers kernel-firmware sudo eliloconfig # or lilo -v if not booting with UEFIThis should be all you ever need to do unless you have a specific reason for needing a different kernel. In that case, the latest one from current may be a good choice, but make sure there are no major incompatibilities first.\nFinal steps - UEFI boot Run eliloconfig rather than lilo. This will copy the new kernel and if applicable the initrd.gz to the correct subdirectory in /boot/efi\nsudo eliloconfigFirst it will ask if you wish to “Install ELILO on the EFI System Partition”. This will ensure you boot the correct, new kernel.\nThen it asks if you want to “install a boot menu entry”. If you just want to boot into Salix, it is ok to choose yes for this, but if you are using rEFInd or grub to multi-boot, select no; the existing configuration should continue to work, giving you the same options as before. For grub, it may be necessary to update grub to register the new kernel. rEFInd just needs it to be in the directory where eliloconfig put it.\nYou can always use guefi (find it in the System menu) to recover lost boot options, should you find they have disappeared.\nFinal steps before rebooting - legacy After upgrading the packages, and creating the new initrd if needed, don’t forget to edit your /etc/lilo.conf file accordingly and run:\nsudo lilo -vto inform the bootloader about the kernel upgrade; or use the tool of your choice to update and reinstall the bootloader.",
    "description": "If you have hardware that is not supported by the kernel that ships with Salix, you can compile your own. In most cases though, it is sufficient to install the latest kernel from the repositories. This page contains instructions for this straightforward procedure, and also for installing the kernel manually. In some cases, if there is a regression, meaning hardware that used to be supported doesn’t work any more, you might actually need to downgrade to an older kernel, but in most cases the solution will be a more recent one.",
    "tags": [],
    "title": "How to Install a Different Kernel",
    "uri": "/user/install-different-kernel/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "This page is about using the standard installation images, not the live images. If you want to install SalixLive on your USB drive, follow these instructions instead: How to install salix live on a USB key\ndd This is the recommended method to create a Salix installation bootable USB stick. It will destroy all previous contents in it, so make sure you make a backup of any data you want to keep.\nOpen a terminal in the same directory the iso image you want to write is located and run:\ndd if=your-salix-iso-image.iso of=/dev/sdbreplacing your-salix-iso-mage.iso with the actual iso name and /dev/sdb with the actual device node of your USB stick\nWARNING: Make absolutely sure you get the device node right. In this example it’s /dev/sdb, but it could be something entirely different in your system as it depends on the number of hard drives or other external mediums you have connected at any time.\nUnetbootin Unetbootin should also work, most of the times, but in some cases in may fail. Your mileage may vary…\nCreate your USB stick with UNetbootin (available on many distributions and for Windows on their website). If you’re using the 32-bit version and have an smp CPU (most probably you do), when booting the USB stick, make sure you are using the hugesmp.s kernel, not the huge.s kernel, which doesn’t support smp. Installation During installation, when prompted for the installation medium choose “Install from a Salix USB stick”. That should do it…",
    "description": "This page is about using the standard installation images, not the live images. If you want to install SalixLive on your USB drive, follow these instructions instead: How to install salix live on a USB key\ndd This is the recommended method to create a Salix installation bootable USB stick. It will destroy all previous contents in it, so make sure you make a backup of any data you want to keep.",
    "tags": [],
    "title": "Install Salix from a USB stick",
    "uri": "/user/install-from-usb/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "If you have hardware that is not supported by the kernel that ships with Salix, you can always compile your own. In most cases though, it is sufficient to install the latest kernel from the repositories. This page contains instructions for this straightforward procedure, and also for installing the kernel manually. In some cases, if there is a regression, meaning hardware that used to be supported doesn’t work any more, you might actually need to downgrade to an older kernel, but in most cases the solution will be a more recent one. This is probably the first thing to try before embarking on building the kernel yourself, which can be quite time-consuming, though it is not really that difficult.\nIt is very important to reinstall the bootloader before you reboot, unless your bootloader is controlled by a Linux installation in another partition.\nInstalling directly from the repositories As a general principle, you should stay with the same kernel series, for example, in Salix 14.2, the 4.4 series; it is preferable to install the latest one from the repositories, ensuring as described below that you include all needed packages, and update the bootloader (see Final steps section below). This is also the most straightforward way of upgrading the kernel. For example:\nsudo slapt-get -i kernel-huge kernel-modules kernel-headers kernel-firmware sudo eliloconfig # or lilo -v if not booting with UEFIThis should be all you ever need to do unless you have a specific reason for needing a different kernel. In that case, the latest one from current may be a good choice as long as it is still within the same kernel series.\nManually installing newer packages You may download and install any newer packages manually. First, you need to determine which packages these would be:\nRun:\nls /var/log/packages/kernel*to see which kernel packages you have installed; these are the ones that need upgrading. For instance, if you don’t have the kernel-source package installed, you don’t need to download the one for your new kernel either. On an x86_64 system, the output might look something like this:\nkernel-firmware-20131008git-noarch-1 kernel-headers-3.10.17-x86-3 kernel-huge-3.10.17-x86_64-3 kernel-modules-3.10.17-x86_64-3Installing the new kernel packages manually If you need a different kernel from the one in the repositories, it needs to be installed manually. Assuming you are using the kernel from current, download the corresponding packages for your architecture from any Slackware current mirror, such as:\nhttp://slackware.oregonstate.edu/slackware64-current/ In the case of that mirror, the packages for a 64-bit system are in the a directory:\nhttp://slackware.oregonstate.edu/slackware64-current/slackware64/a/ Headers are respectively in the d direcotry and the kernel-source package, if needed is in the k directory.\nIf you have a 32-bit system, change slackware64 to slackware:\nhttp://slackware.oregonstate.edu/slackware-current/slackware/a/ Download the packages with a browser, or move to the directory where you will put them and fetch with wget:\nwget -c http://slackware.oregonstate.edu/slackware64-current/slackware64/a/kernel-huge-3.10.30-x86_64-1.txz… etc. In each case, the file you want is the one whose name ends in .txz. (The kernel version number will obviously be different.)\nMove to the directory where you downloaded the packages and install each one using spkg:\nsudo spkg -u kernel-huge-3.10.30-x86_64-1.txz … etc.\nIf you have switched to the kernel-generic package instead of the default kernel-huge package, don’t forget to recreate the initrd.gz file which will be needed for booting your upgraded system. If you’re still using the default kernel-huge package, an initrd is not needed.\nFinal steps - UEFI boot Run eliloconfig rather than lilo. This will copy the new kernel and if applicable the initrd.gz to the correct subdirectory in /boot/efi.\nsudo eliloconfigFirst it will ask if you wish to “Install ELILO on the EFI System Partition”. This will ensure you boot the correct, new kernel.\nThen it asks if you want to “install a boot menu entry”. If you just want to boot into Salix, it is ok to choose yes for this, but if you are using rEFInd or grub to multi-boot, select no; the existing configuration should continue to work, giving you the same options as before. For grub, it may be necessary to update grub to register the new kernel. rEFInd just needs it to be in the directory where eliloconfig put it.\nYou can always use guefi to recover lost boot options, should you find they have disappeared.\nFinal steps before rebooting - legacy After upgrading the packages, and creating the new initrd if needed, don’t forget to edit your /etc/lilo.conf file accordingly and run:\nsudo lilo -vto inform the bootloader about the kernel upgrade; or use the tool of your choice to update and reinstall the bootloader.",
    "description": "If you have hardware that is not supported by the kernel that ships with Salix, you can always compile your own. In most cases though, it is sufficient to install the latest kernel from the repositories. This page contains instructions for this straightforward procedure, and also for installing the kernel manually. In some cases, if there is a regression, meaning hardware that used to be supported doesn’t work any more, you might actually need to downgrade to an older kernel, but in most cases the solution will be a more recent one.",
    "tags": [],
    "title": "Install Kernel From Current",
    "uri": "/user/install-kernel-from-current/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "The kernel-source package is by default locked in gslapt, just like all other kernel related packages. This is to prevent users from unknowingly upgrading the kernel; it’s easy to miss that kernel packages are about to be upgraded, when a multitude of other packages are going to be upgraded at the same time.\nSalix 14.1 and newer To install the kernel-source package, in Salix 14.1 and newer use sudo . Open a terminal window and run:\nsudo slapt-get -uand request to install the kernel-source package explicitly with slapt-get:\nsudo slapt-get -i kernel-sourceThat’s it, the kernel-source package should be downloaded and installed when the download is finished.\nMake sure the kernel-source package you are installing matches your current kernel. You can check the currently installed kernel packages with:\nls /var/log/packages/kernel-*If the kernel-source package version does not match your current kernel, you need to upgrade your kernel packages first. See How to install a different kernel for how to do this.\nSalix 14.0 and earlier In order to install the kernel-source package, open a terminal window, run\nsuand provide your root password to become root. Update your package database (just to be sure):\nslapt-get -uand request to install the kernel-source package explicitly with slapt-get:\nslapt-get -i kernel-sourceThat’s it, the kernel-source package should be downloaded and installed when the download is finished.",
    "description": "The kernel-source package is by default locked in gslapt, just like all other kernel related packages. This is to prevent users from unknowingly upgrading the kernel; it’s easy to miss that kernel packages are about to be upgraded, when a multitude of other packages are going to be upgraded at the same time.\nSalix 14.1 and newer To install the kernel-source package, in Salix 14.1 and newer use sudo . Open a terminal window and run:",
    "tags": [],
    "title": "How to Install the Kernel Source",
    "uri": "/faq/kernel-source/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "You need to close all running applications during the installation of the driver. Therefore if you want to be able to view these instructions while working through them you should open them on another computer or create a printout.\nPrerequisites Download the proprietary NVIDIA driver and save it to a known location. Throughout this guide we assume you used your home directory. Install the kernel sources Installation Close all your applications and save all data. Also log out if possible. Now press Ctrl + Alt + F2 to go to a terminal in text-mode and login. Now terminate X by dropping to runlevel 3 (text-mode only): sudo init 3 Now change to the folder where you saved the NVIDIA driver. If it’s in your home directory, run: cd ~ Now start the installer: sudo sh NVIDIA-Linux-*.run Follow the instructions of the installer. Select to update your xorg.conf. Otherwise you need to do so manually. When finished, reboot: sudo rebootYou can tweak some settings with the nvidia-settings tools now, if you need/want to. To be able to save any such changes to your xorg.conf you need to run the nvidia-settings tool as root.",
    "description": "You need to close all running applications during the installation of the driver. Therefore if you want to be able to view these instructions while working through them you should open them on another computer or create a printout.\nPrerequisites Download the proprietary NVIDIA driver and save it to a known location. Throughout this guide we assume you used your home directory. Install the kernel sources Installation Close all your applications and save all data.",
    "tags": [],
    "title": "How to Install the Proprietary NVIDIA Driver",
    "uri": "/user/install-nvidia/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "These instructions are for LiveCD images of Salix only!!! If your iso image file does not have ’live’ in it’s name look at these instructions: Install-from-USB\nIt depends if you already have a Salix Live CD or simply an ISO image. Unetbootin version \u003c 575 is not supported and should not be used. Versions greater or equal to 575 have been reported to correctly deal with USB installation and persistence; however it does not seem to work for all users. In that case, use the script in the boot directory as described below.\nThese mostly automatized methods to install the LiveCD to an USB only support sticks formatted as FAT (FAT16, FAT32, VFAT), as supported by syslinux, and a MBR partition table (no GPT). If you don’t know what this means, you most probably have such a stick. Other setups are very uncommon and require you to do all the work manually.\nIf you have any important data on the stick, please do create a backup before continuing! Although we’ve carefully written those scripts to protect your data, we make no guarantees whatsoever.\nFrom a Salix Live CD Boot a Live session from the CD. Insert your USB key. Use LiveClone. From an ISO image You need to at least install parted and syslinux. Installation of lilo is optional, but highly recommended. Open the ISO file using a software archiver (file-roller, xarchiver, 7-zip, iso-master, …) Extract all files and folders (boot, packages, salixlive and salix-\u003c…\u003e.live) to your USB root directory Go to the “boot” directory on the USB key. If you’re on Unix (Linux, BSD, Max OS X), simply execute the file called “install-on-USB.sh” (root privileges are required) If you’re on Windows, execute the file called “install-on-USB.cmd” instead. Walkthrough with file-roller on Linux This is to give you a more precise idea how it’s done. We’re assuming you’re using file-roller as your default archive manager and Thunar as your file manager, but for other tools like xarchiver it should work quite similarly. If you have such other tools don’t be surprised if the screenshots are not exactly what you’re seeing. ;)\nThe script requires parted and syslinux to be installed - lilo is also highly recommended. If installation to USB is unsuccessful, this is the first thing to check using your existing distro’s package manager. Browse to the directory where you downloaded the ISO image file to and open it by double-clicking. This should bring up your default archive manager. Now select the Extract button. In the popping up dialog window select your USB stick in the left column. For me it’s “TEST”. If the USB Stick doesn’t show up, try opening it first in your regular file manager. Also make sure that the same tickboxes/radio buttons are selected in the bottom of the window (Extract “All files”, “Re-create folders” and “Overwrite existing files”).\nNow press the Extract button and wait until the operation is finished. If it is, press the Quit button.\nOpen your file manager and navigate to your USB stick. Open the boot directory in the root of your stick. Start the installation by double-clicking the install-on-USB.sh script.\nYou need to enter your root password because administrative privileges are required.\nNow follow the on-screen instructions. It should be safe to always say yes, after checking whether the right devices have been chosen. Finally you should end up like this:\nIf you end up getting a error message, first try to make some sense out of it. You might be missing one of the utilities mentioned before (syslinux, parted, lilo). IMPORANT!!! Be sure to unmount your stick and to wait for it to become really unmounted after all data has been written onto the device. Don’t unplug it before it’s really unmounted. For Thunar and many other file managers unmounting works by right-clicking onto the device in the left-hand panel.\nIf the stick is really unmounted and all data has been written, this is somehow indicated. For example by graying out the device. Now you may safely unplug your stick if you want.\nDone! Now reboot with your stick plugged in and select it as the boot device for your BIOS.\nMany BIOS offer a Boot Selection Menu for this task, which is accessible for example by pressing F12. Otherwise you might have to enter your BIOS Setup and change the boot device order/priority. Troubleshooting Early failures (i.e. not reaching the Live bootmenu) This is often caused by various problems with the partitioning/MBR of USB sticks.\nBefore continuing please back up all data on any partition of the stick because we’re going to delete all of it next! Also be sure you’ve got the right device name for your stick (e.g. /dev/sdb and not /dev/sdb1)! If you accidentally use the wrong device the data on it could be permanently LOST! To check the device name open the stick in your file manager and consult the output of the mount command. Another useful utility here can be blkid. Later this device name is referred to as and should be replaced by whatever you found out.\nFirst, be sure to unmount the stick in your file manager or wherever else it is mounted. Now run this to clean the stick up: dd if=/dev/zero of=\u003cdevname\u003e bs=512 count=4096 Now start GParted and select to create a new disklabel. It should be a msdos one. Finally create one partition as you like. Apply the changes and replug the stick to your computer. It should now show up again in your file manager and you can install Salix Live as by the instructions above again. If the problem persists ask for help in the Salix forum.\ninstall-on-USB.sh does not run correctly Open a terminal and become root Type mount to check where the stick is mounted, for instance, something like /run/media/{youruser}/{very long Hex number} cd /run/media/foo/bar/boot # replace 'foo' and 'bar' with the appropriate username and number Run the script specifying the shell: sh ./install-on-USB.shIf that still does not work, you may need to mount the stick manually. First, find out the stick’s partition and where it is currently mounted as above, and make sure no directory under that mountpoint is open (close the file manager and any other terminal windows); then, as root:\nUnmount the stick: umount \u003cpartition name\u003e \\# e.g. /dev/sdb1 Create a directory to mount the stick to, remount it, and move to its /boot directory: mkdir /tmp/livemount mount -t vfat -o exec /dev/sdb1 /tmp/livemount cd /tmp/livemount/boot For good measure, make sure the script is executable, then run it:\\ chmod +x ./install-on-USB.sh sh ./install-on-USB.sh Answer yes to the questions. If you still have trouble, please ask on the forum.",
    "description": "These instructions are for LiveCD images of Salix only!!! If your iso image file does not have ’live’ in it’s name look at these instructions: Install-from-USB\nIt depends if you already have a Salix Live CD or simply an ISO image. Unetbootin version \u003c 575 is not supported and should not be used. Versions greater or equal to 575 have been reported to correctly deal with USB installation and persistence; however it does not seem to work for all users.",
    "tags": [],
    "title": "How to Install Salix Live on a USB Key?",
    "uri": "/user/salixlive/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "Generally, you can’t.\nWhile technically they are very similar, txz and tgz files are in fact tar.xz and tar.gz files, they are not the same. It’s essential to understand that what you found might not be a Slackware package, even if it has the same extension. Most likely, it’s a source tarball, which is different from a Slackware package.\nTo confuse matters more, some people create source tarballs and name them with a txz or tgz extension, instead of the more usual tar.xz and tar.gz extensions.\nThe format that Salix uses for its packages comes from Slackware. A Slackware package (txz or tgz) is created with a specific version of tar and follows a particular directory structure. It includes files that are organized according to your system’s hierarchy, such as binaries in /usr/bin and manpages in /usr/man. On the other hand, a source tarball usually contains only the source code.\nThere are some easy ways to figure out if a file is indeed a package file and not just a general purpose tarball. First, you can look at the filename. Packages follow a certain naming convention, they should look something like this:\nsalixtools-gtk-2.5.7-noarch-1gv.txzThis can be split in four different parts, delimited by dashes: the package name (in this case “salixtools-gtk”), the package version (“2.5.7”), the architecture (in this case “noarch”, but it could be “x86_64” or “i686” among others), the packaging release number (in this case “1gv”), which is just a number that is incremented every time the same version of the software is repackaged and finally the extension (“txz”).\nAn additional check you can make is list the file’s contents. You can do that with something like:\ntar tf salixtools-gtk-2.5.7-noarch-1gv.txzor opening with your GUI archiver. If it is indeed a package file, there should be an install/slack-desc file somewhere in there. In the terminal you can just run:\ntar tf salixtools-gtk-2.5.7-noarch-1gv.txz | grep ^installand you should see something like this:\ninstall/ install/slack-descIf you have that, then chances are this is indeed a valid Slackware package.\nBut even then, you should be very cautious about installing it in your system. As a rule of thumb, never blindly trust binaries that you download online. It could also be the case that whoever created the package had no malicious intentions, yet it could still break your system. This could happen by replacing a key system library, which may have worked in the package creator’s system, but not on yours. After all, the package may have been intended for a different Slackware (and therefore Salix) release or for a different architecture than yours.\nIf what you found is indeed a package and you really want to install it, then you can just run spkg like this example:\nsudo spkg salixtools-gtk-2.5.7-noarch-1gv.txz",
    "description": "Generally, you can’t.\nWhile technically they are very similar, txz and tgz files are in fact tar.xz and tar.gz files, they are not the same. It’s essential to understand that what you found might not be a Slackware package, even if it has the same extension. Most likely, it’s a source tarball, which is different from a Slackware package.\nTo confuse matters more, some people create source tarballs and name them with a txz or tgz extension, instead of the more usual tar.",
    "tags": [],
    "title": "How Do I Install a txz/tgz File I Found Online?",
    "uri": "/faq/install-txz-found-online/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "If you’re running Salix inside a virtualbox VM, you’ll find out that the virtualbox guest additions fail to install, with some kernel header error being thrown. In order to be able to install the virtualbox guest additions, you just need to install the kernel-source package. Reboot and the virtualbox guest additions will install with no errors after that.",
    "description": "If you’re running Salix inside a virtualbox VM, you’ll find out that the virtualbox guest additions fail to install, with some kernel header error being thrown. In order to be able to install the virtualbox guest additions, you just need to install the kernel-source package. Reboot and the virtualbox guest additions will install with no errors after that.",
    "tags": [],
    "title": "How to Install the Virtualbox Guest Additions in a Salix Guest",
    "uri": "/user/install-guest-additions-in-virtualbox-guest/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Installing Xorg The easiest way to install Xorg on top of Salix Core is to install everything under the /x repository directory. To do that, first update your package database\nslapt-get -uand then run:\nslapt-get --install-set xThat will install every package that is in the /x directory and will give you a working Xorg. It would be a good idea to install some icon themes, or many apps won’t display properly:\nslapt-get -i icon-naming-utils hicolor-icon-theme tango-icon-themeInstall a Window Manager Most people would want something other than TWM, so you can install a minimal window manager, like icewm or fluxbox:\nslapt-get -i icewmor\nslapt-get -i fluxboxor similar for the one you want to install.\nTo make that window manager the default for your user, do\ncp /etc/X11/xinit/xinit.icewm ~/.xinitrcfor icewm, or\ncp /etc/X11/xinit/xinit.fluxbox ~/.xinitrcfor fluxbox, or similar for any other window manager, you get the point.\nYou can now test your favourite minimal window manager with:\nstartxGraphical login If you want to have a graphical login screen, you have to install lightdm:\nslapt-get -i lightdmPerhaps it’s a good idea to test lightdm before you set it as default. Start the graphical login manager with:\ninit 4If it works you can edit /etc/inittab and replace the following lines\n# Default runlevel. (Do not set to 0 or 6) id:3:initdefault:with\n# Default runlevel. (Do not set to 0 or 6) id:4:initdefault:Additional software You can then add any graphical apps you might be needing with slapt-get.\nYou can of course remove any unnecessary Xorg packages that you may not need.",
    "description": "Installing Xorg The easiest way to install Xorg on top of Salix Core is to install everything under the /x repository directory. To do that, first update your package database\nslapt-get -uand then run:\nslapt-get --install-set xThat will install every package that is in the /x directory and will give you a working Xorg. It would be a good idea to install some icon themes, or many apps won’t display properly:",
    "tags": [],
    "title": "How to Install Xorg on Salix Core",
    "uri": "/user/xorg-on-core/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "If you find the need to open an extra virtual console during the installation of Salix, you’ll find out that the Ctrl-Alt-Fx key combinations do not do anything. In order to enable that, you just need to exit the installation as soon as it starts when you’re prompted to proceed or exit the installation, right after you select your preferred keyboard map. If you do so, you’ll find that virtual terminals 2 and 3 are now available and you can switch to them with Ctrl-Alt-F2 and Ctrl-Alt-F3 respectively. In order to get back to the installation, you just need to type:\nsetup",
    "description": "If you find the need to open an extra virtual console during the installation of Salix, you’ll find out that the Ctrl-Alt-Fx key combinations do not do anything. In order to enable that, you just need to exit the installation as soon as it starts when you’re prompted to proceed or exit the installation, right after you select your preferred keyboard map. If you do so, you’ll find that virtual terminals 2 and 3 are now available and you can switch to them with Ctrl-Alt-F2 and Ctrl-Alt-F3 respectively.",
    "tags": [],
    "title": "How to Get an Extra Console in the Salix Installer",
    "uri": "/faq/extra-console/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation",
    "content": "Modification of the original script (We shall take excerpts from the script keyboardsetup as an example.)\nAdd the following lines after the usual introductory comments but before your actual code starts:\n# Gettext internationalization export TEXTDOMAIN=\"name_of_the_program\" export TEXTDOMAINDIR=\"destination_path_to_the_compiled_translations\" . gettext.shExample Before modification:\n# Version 4.3 - 28/07/2009 # * replaced xorg.conf by fdi policy rule # Take a look at \"Xdialog\" and use it instead of \"dialog\" in case X is running if [[ \"$DISPLAY\" \u0026\u0026 \"$(which Xdialog 2\u003e\u00261 | grep -v \"which: no\")\" ]]; thenAfter modification:\n# Version 4.3 - 28/07/2009 # * replaced xorg.conf by fdi policy rule # Gettext internationalization export TEXTDOMAIN=\"keyboardsetup\" export TEXTDOMAINDIR=\"/usr/share/locale\" . gettext.sh # Take a look at \"Xdialog\" and use it instead of \"dialog\" in case X is running if [[ \"$DISPLAY\" \u0026\u0026 \"$(which Xdialog 2\u003e\u00261 | grep -v \"which: no\")\" ]]; thenPut the following tags around the strings that need to be translated:\n`eval_gettext 'string_to_be_translated'`Example Before modification:\nif [ \"$xflag\" = \"yes\" ] ; then answer=\"$(eval $dialog \\ --stdout \\ --title \\\"Keyboard configuration\\\" \\ --default-item \\\"$currentpathkeymap\\\" \\ --cancel-label \\\"Exit\\\" \\ --icon \\\"keyboardsetup\\\" \\ --check \\\"numlock\\\" \\\"on\\\" \\ --menu \\ \\\"\\\\n Please select your prefered keyboard map:\\\" 20 75 11 \"$list\" )\" elseAfter Modification:\nif [ \"$xflag\" = \"yes\" ] ; then answer=\"$(eval $dialog \\ --stdout \\ --title \\\"`eval_gettext 'Keyboard configuration'`\\\" \\ --default-item \\\"$currentpathkeymap\\\" \\ --cancel-label \\\"`eval_gettext 'Exit'`\\\" \\ --icon \\\"keyboardsetup\\\" \\ --check \\\"numlock\\\" \\\"on\\\" \\ --menu \\ \\\"\\\\n `eval_gettext 'Please select your prefered keyboard map:'`\\\" 20 75 11 \"$list\" )\" elseTranslation process We first need to extract the strings to be translated from the shell script to a model file that will be distributed to the translators. To do this, run the following command from the working directory where the shell script is located:\nxgettext --from-code=utf-8 -L shell -o name_of_shell_script.pot name_of_shell_scriptExample xgettext --from-code=utf-8 -L shell -o keyboardsetup.pot keyboardsetupEach translator will use the model file to generate his own translation work file by running the following command from the directory where the .pot file (our translation model) is located. It is assumed that the environment locale of his operating system is the same as the locale he wants to translate into (or else he should consult the man page of msginit):\nmsginit -i name_of_shell_script.pot -o name_of_shell_script-name_of_locale.poExample msginit -i keyboardsetup.pot -o keyboardsetup-fr.poTranslate using PoEdit The easiest way to localize a gettext software is to install poedit from the repositories.\nIf there is already a .po file for your language and you just want to update/correct it, you can open the .po file directly with poedit.\nIf a .po file for your language doesn’t exist yet, you can create one easily with poedit, just select “New catalog from .POT file” from the file menu, add your details and start translating!\nRemember to save the .po file you created like this:\nsoftname-langcode.poExample keyboardsetup-de.po (for German)Translate without PoEdit If there is no .po file for your language yet, you can create one from the .pot file with a command like this:\nmsginit -i name_of_shell_script.pot -o name_of_shell_script-name_of_locale.poExample msginit -i keyboardsetup.pot -o keyboardsetup-fr.poWhen you create a .po file, or if one is already there, you can start editing it directly. Looking into the file is self explanatory, using a text editor of his choice each translator translate the strings in his language .po file.\nExample Before:\n#: keyboardsetup:93 keyboardsetup:103 #, sh-format msgid \"Keyboard configuration\" msgstr **After:\n#: keyboardsetup:93 keyboardsetup:103 #, sh-format msgid \"Keyboard configuration\" msgstr \"Configuration du clavier\"Testing your translations If you want to test your translation, you need to create a .mo file from the .po file, like this:\nmsgfmt name_of_shell_script-name_of_locale.po -o name_of_shell_script.moExample msgfmt keyboardsetup-fr.po -o keyboardsetup.moThe .mo filename should be exactly the same as the tool you are translating.\nYou can then place the .mo file you generated into its appropriate locale directory:\n/usr/share/locale/name_of_locale/LC_MESSAGES/Example /usr/share/locale/fr/LC_MESSAGES/Sending your translations You can send your .po files to the salix-main mailing list (or the software author email) and they will be included in future versions of salixtools or other software. If it’s a salixtools, just send an email to [mailto:salix-main@lists.sourceforge.net] attaching your .po files.\nExtending the translations to the shell script When the maintainer of the shell script receives back a completed .po file from a translator, he first compiles it by running the following command (from the working directory where the translated po file is located):\nmsgfmt name_of_shell_script-name_of_locale.po -o name_of_shell_script.moExample msgfmt keyboardsetup-fr.po -o keyboardsetup.moThen he places the .mo file he generated into its appropriate locale directory:\n/usr/share/locale/name_of_locale/LC_MESSAGES/Example /usr/share/locale/fr/LC_MESSAGES/That’s all!\nMaintenance Maintenance of the shell script \u0026 future translations:\nIf later on, the shell script is modified, its maintainer will issue a new .pot (model) file which he can send back to the translators.\nEach translator will then have to run the following command in order to generate a new .po file for their language that will include their previous translation work as well as the new strings net yet translated. Both the new .pot file \u0026 the last translated .po file should be located in the directory where this command is issued.\nmsgmerge -U name_of_shell_script-name_of_locale.po name_of_shell_script.potExample msgmerge -U keyboardsetup-fr.po keyboardsetup.potAnd then redo the missing translations.",
    "description": "Modification of the original script (We shall take excerpts from the script keyboardsetup as an example.)\nAdd the following lines after the usual introductory comments but before your actual code starts:\n# Gettext internationalization export TEXTDOMAIN=\"name_of_the_program\" export TEXTDOMAINDIR=\"destination_path_to_the_compiled_translations\" . gettext.shExample Before modification:\n# Version 4.3 - 28/07/2009 # * replaced xorg.conf by fdi policy rule # Take a look at \"Xdialog\" and use it instead of \"dialog\" in case X is running if [[ \"$DISPLAY\" \u0026\u0026 \"$(which Xdialog 2\u003e\u00261 | grep -v \"which: no\")\" ]]; thenAfter modification:",
    "tags": [],
    "title": "How to Internationalize Shell Scripts",
    "uri": "/dev/internationalize-shell-scripts/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "It should be noted that the default kernel that ships with Salix will work in most cases, and no recompiling is necessary. You should only recompile if:\nYour system’s hardware is not supported by the default kernel You need (want) features only available in a newer kernel To get an extra fraction of a percent hardware performance For fun Before going ahead, it may be easier (and will in many cases be sufficient to solve the problem) to install the kernel from Slackware current, which will always be relatively recent.\nThe procedure is actually quite simple, as long as you remember to reinstall the bootloader before rebooting. However, it can take a long time.\nDownload the kernel source You may either compile a completely new kernel from source, or recompile the kernel that is packaged by Salix with new configuration.\nNew kernel from kernel.org First, download the appropriate kernel source from http://www.kernel.org\nYou will need the full kernel source tarball (the one with the tar.xz extension).\nUnpack source into a directory of your choosing (any directory will do, preferably somewhere in your home directory).\nAlready installed kernel Alternatively, you could rebuild the already installed kernel. For that, you will need to install the kernel-source package, if you don’t have it already:\nsudo slapt-get -i kernel-sourceThe kernel source will then be in /usr/src/linux-3.2.25 (change 3.2.25 to the appropriate version.\nPreparation Move to the directory that the kernel source is and run:\nmake mrproperThis is a cleaning procedure and will set everything to default. You can work from here, but it is highly recommended to use the working configuration (i.e. the one you’ve been running on). The default kernel config is found in /proc/config.gz, so copy this file:\nzcat /proc/config.gz \u003e .configNext, you can configure your kernel. The advantage of using the working configuration as a starting-point is you can leave nearly all the options just as they are, but it may be that you need to turn on support for the hardware that doesn’t work with the existing kernel; or it may work with the new kernel without changing anything at all. To build the kernel with the working configuration unchanged, do:\nmake oldconfigIf you do need to change anything, there is a choice of interfaces for the configuration. To use a graphical interface, do:\nmake gconfigfor the gtk-based config, or on a KDE system\nmake xconfigfor a qt interface.\nmake menuconfigwill bring up the ncurses based menu-driven config, which will work even if you’re not running X.\nThe number of different options may appear bewildering, but pretty much all of them can (indeed should) be left unchanged from the working configuration. If in doubt, as a rule of thumb, it is probably best to leave it as is.\nCompiling Once you have configured the kernel to your liking, save and exit. Then do:\nmaketo build the kernel. This will take some hours…\nInstalling After it’s done, do:\nsudo make modules_installto install all of the modules. All of the modules will be installed under /lib/modules/version, where version corresponds to the release number of the kernel compiled.\nNext, copy the created kernel image and system map to the boot directory.\nsudo cp -v arch/x86/boot/bzImage /boot/vmlinuz-version sudo cp -v System.map /boot/System.map-versionwhere version corresponds to the release number of the kernel compiled.\nAssuming the kernel in your working system is the standard one that came with Salix, the new one you just built will also be a ‘huge’ kernel that doesn’t need an initrd, so you can omit the next step.\ninitrd However, if you know you do need to create an initrd.gz file:\n/usr/share/mkinitrd/mkinitrd_command_generator.sh -l /boot/vmlinux-versionwill generate a mkinitrd command that you can then copy and paste. By default, it will output to /boot/initrd.gz. You may want to change this when cutting and pasting so that it will output to /boot/initrd-version.gz. Note that a suggested lilo stanza is also created, but the initrd itself is only made when you run the mkinitrd command itself. To do so, root privileges are required.\nRefresh LILO As a final step, edit /etc/lilo.conf so that it will see the newly created kernel, including the ‘initrd’ line only if you created one:\nimage = /boot/vmlinuz-version root = /dev/sda6 initrd = /boot/initrd-version.gz label = \"New Kernel\" read-onlyDon’t forget to run:\nsudo liloto take effect of the new configuration; or use whichever tool you prefer to install the bootloader.\nThat’s it. When you reboot, you should see the new kernel in the lilo menu, and everything should work. As a check, after the system reboots itself: uname -a\nYou should see that the kernel release number is indeed the version you just built.\nThe old kernel is still present, and your bootloader will still include an option to boot with it as a fallback. Once you are certain everything is working properly with the new one, you may wish to remove the old entry from the bootloader and (optionally, with care) delete the old kernel in /boot.",
    "description": "It should be noted that the default kernel that ships with Salix will work in most cases, and no recompiling is necessary. You should only recompile if:\nYour system’s hardware is not supported by the default kernel You need (want) features only available in a newer kernel To get an extra fraction of a percent hardware performance For fun Before going ahead, it may be easier (and will in many cases be sufficient to solve the problem) to install the kernel from Slackware current, which will always be relatively recent.",
    "tags": [],
    "title": "How to Compile the Linux Kernel",
    "uri": "/user/kernel-compilation/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "LILO (the LInux LOader) is the default bootloader for Salix for systems that use a BIOS, instead of an EFI implementation to boot. This page provides some tips with respect to LILO usage.\nLILO is loading slowly Sometimes LILO is booting very slowly showing lines of dots on the screen. To fix this just add a line containing “compact” (without quotes) at the top inside the global section of /etc/lilo.conf by editing it through a text editor or LiloSetup; then reinstall LILO.\nChainload another system or bootloader With the two simple lines below you’re able to chainload - which is much like redirection - another bootloader (or system) that is able to continue the boot process by itself:\nother = /dev/partition label = Namewhere partition stands for i.e. sda1, sda5, etc.\nMost often this is used to boot Windows by chainloading its own native bootloader:\nother = /dev/sda1 label = WindowsHowever it also allows to chainload another LILO or GRUB instance if either was not installed in the MBR but on a separate partition. For example assume Fedora installed its bootloader on partition sda5 and Salix in MBR (sda). In such case we can load Fedora`s bootloader with:\nother = /dev/sda5 label = FedoraJust add these two lines below the global section of /etc/lilo.conf among other entries for Linux.\nCustom bitmap for LILO This is quite easy with GIMP:\nTake an image Scale it to 640x480 Choose Image-\u003eMode-\u003eIndexed Generate optimum palette (255 colors, you may want to experiment with dithering to gain quality) Save as name.bmp (Windows BMP Image) enable Run-Length Encoded during saving Copy the new image to the /boot directory and specify its name in /etc/lilo.conf by finding and modifying the line:\nbitmap = /boot/name.bmpReinstall LILO:\nsudo lilo -vIf it complains about the bitmap then one of the steps above must have gone wrong. Here you find an example colored LILO bitmap for Salix\nAdding Memtest Memtest is a useful tool that allows testing memory for errors. It is easy to add it to LILO menu:\nDownload memtest as Pre-Compiled Bootable Binary (.gzip or .zip) extract it into /boot directory rename to memtest to simplify LILO entry add the two lines as below to /etc/lilo.conf below the global section among other entries for Linux and reinstall LILO image=/boot/memtest label=MemtestRestrict passing parameters Passing parameters to the kernel with LILO is not restricted by default, so anybody can type ’ init 1’ and boot into single user mode. If you want to protect parameters with a password, add these two lines at the top inside the global section of /etc/lilo.conf :\npassword=define_your_password_here restrictedYour system will boot as usual but it will ask for the password when someone wants to add a parameter to the kernel. Since the password is not hidden make sure lilo.conf is only readable by root:\nchmod 600 /etc/lilo.conf Warning This doesn’t prevent a person who really wants to bypass this limitation from doing so. Such a person can still change data (e.g. root password or LILO password) by booting from another media (e.g. Salix LiveCD) unless BIOS booting sequence doesn`t allow it or by attaching the hard drive to another computer if he has physical access to it.",
    "description": "LILO (the LInux LOader) is the default bootloader for Salix for systems that use a BIOS, instead of an EFI implementation to boot. This page provides some tips with respect to LILO usage.\nLILO is loading slowly Sometimes LILO is booting very slowly showing lines of dots on the screen. To fix this just add a line containing “compact” (without quotes) at the top inside the global section of /etc/lilo.conf by editing it through a text editor or LiloSetup; then reinstall LILO.",
    "tags": [],
    "title": "LILO",
    "uri": "/user/lilo/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "What is mateconf? MATEConf is a configuration scheme currently used by the MATE desktop. Programs which use it setup default values in a $NAME.schemas file which is installed under /etc/mateconf/schemas/$NAME.schemas. These defaults are then registered with the mateconf daemon which monitors the configuration values and alerts applications when values the applications are interested in change. The schema files also provide documentation about what each value in the configuration system means (which gets displayed when you browse the database in the mateconf-editor program).\nFor packaging purposes, we have to disable schema installation during build, or these will get installed in the packager’s system instead of put in the package itself. They can then be created and placed in the package manually.\nDisabling schemas installation When a package requires the installation of mateconf schemas, there is usually a “–disable-schemas-install” configure option that can be used to not let the makefile install any schemas to the system. You can check if the configure script provides such an option with “configure –help”.\nSometimes the configure script accepts a “–with-mateconf-source” option. This should be used together with “–disable-schemas-install” like this, in order to set where and how the app should store its settings in mateconf:\n./configure other_configure_options --disable-schemas-install --with-mateconf-source=\"xml::/etc/mateconf/mateconf.xml.defaults\"However, the “–disable-schemas-install” option might not be working properly, or it might not even be available. In that case a MATECONF_DISABLE_MAKEFILE_SCHEMA_INSTALL variable must be declared when running make install, like this:\nMATECONF_DISABLE_MAKEFILE_SCHEMA_INSTALL=1 make install DESTDIR=$startdir/pkgwhere $startdir/pkg is your packaging directory (as used by [[SLKBUILD]]).\nBe careful not to do:\nexport MATECONF_DISABLE_MAKEFILE_SCHEMA_INSTALL=1at any point in your buildscript as pointed in some other sites about using mateconf in other distributions, because the setting will stick and you won’t be allowed to install the schemas manually later on in your buildscript.\nInstalling schemas in the package Files with the .schemas extension will be created under the $startdir/pkg directory after running “make install” as specified above. Now, we need to manually register those schemas within the packaging directory. This can be achieved by putting something like this in your buildscript somewhere after the “make install” line:\n# mateconf stuff export MATECONF_CONFIG_SOURCE=\"xml::$startdir/pkg/etc/mateconf/mateconf.xml.defaults\" if [ -d $startdir/pkg/etc/mateconf/schemas ]; then install -v -d -m755 $startdir/pkg/etc/mateconf/mateconf.xml.defaults SCHEMAS=$startdir/pkg/etc/mateconf/schemas for schema in $SCHEMAS/*.schemas; do mateconftool-2 --makefile-install-rule $schema done # Reset / Verify correct permissions ( cd $startdir/pkg/etc/mateconf ; find . -type d -exec chmod 755 {} \\; ) ( cd $startdir/pkg/etc/mateconf ; find . -type f -exec chmod 644 {} \\; ) fiwhere, as before, $startdir/pkg is your packaging directory. This will register any .schemas files present in $startdir/pkg/etc/mateconf/schemas and put their default settings inside the package.\nSLKBUILD and mateconf schemas files If you are using SLKBUILD to create your packages, the default behaviour is to make every file under /etc a .new file automatically. A .new file does not replace any older versions of the same file, this happens only after the user explicitly allows it to overwrite the older (already installed by a previous version of the package) file. While this is the recommended setting for most settings files that are placed in /etc, this is not the case for mateconf settings files. Gconf settings files, just provide reasonable defaults for applications, which are tweaked, in an automated way, inside the users home directory. New mateconf settings files should always replace previously installed files, because in many cases, they include changes that are necessary for the newer version of the software to work properly.\nSo, when you are installing mateconf schemas in your package, make sure you add the noautodotnew option in your SLKBUILD:\noptions=('noautodotnew')and add any other files that you want to be .new’d in the dotnew=() array (see man SLKBUILD for details)",
    "description": "What is mateconf? MATEConf is a configuration scheme currently used by the MATE desktop. Programs which use it setup default values in a $NAME.schemas file which is installed under /etc/mateconf/schemas/$NAME.schemas. These defaults are then registered with the mateconf daemon which monitors the configuration values and alerts applications when values the applications are interested in change. The schema files also provide documentation about what each value in the configuration system means (which gets displayed when you browse the database in the mateconf-editor program).",
    "tags": [],
    "title": "MATEConf Schemas and Packaging",
    "uri": "/dev/packaging/mateconf/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "When your package includes xml files in usr/share/mime, the system should be informed about the new mimetypes when the package is installed. That can be accomplished by entering the following code in your doinst.sh:\n#update the mime desktop database if [ -x usr/bin/update-desktop-database ]; then usr/bin/update-desktop-database -q fi # update the mime database if [ -x usr/bin/update-mime-database ]; then usr/bin/update-mime-database usr/share/mime \u003e /dev/null 2\u003e\u00261 fi",
    "description": "When your package includes xml files in usr/share/mime, the system should be informed about the new mimetypes when the package is installed. That can be accomplished by entering the following code in your doinst.sh:\n#update the mime desktop database if [ -x usr/bin/update-desktop-database ]; then usr/bin/update-desktop-database -q fi # update the mime database if [ -x usr/bin/update-mime-database ]; then usr/bin/update-mime-database usr/share/mime \u003e /dev/null 2\u003e\u00261 fi",
    "tags": [],
    "title": "Installing Mimetypes with a Package",
    "uri": "/dev/packaging/mimetypes/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": " Warning Multilib is not officially supported in Salix and it is not recommended. Follow these instructions at your own risk.\nOriginal Source\nIn this guide we will discuss how to install multilib support for 32bit apps on a 64bit Salix. It is based on a ‘full’ version of Salix. The source guide is more in-depth, this guide is only the minimal steps required for Salix. If you are using a more recent Salix version, adjust ‘15.0’ accordingly.\nObtain/Install multilib Packages The multilib-enabled packages and scripts are available for download from AlienBob’s multilib repository\nAll the required packages can be downloaded into your home\u003edownload with the following command:\ncd ~/Download/ wget -r -l1 --no-parent http://connie.slackware.com/~alien/multilib/15.0/To install the packages, we will run the terminal within the ‘15.0’ directory downloaded above, then install:\ncd ~/Download/connie.slackware.com/~alien/multilib/15.0/ su upgradepkg --reinstall --install-new *.t?zObtain/Install 32-Bit Slackware Package Tree The instructions on the source page require you to setup a package tree and then convert the packages to suit.\nAlternatively, the essential and already converted packages can be downloaded and installed with the following commands:\ncd ~/Download/ wget -r --no-parent http://connie.slackware.com/~alien/multilib/15.0/slackware64-compat32/ cd ~/Download/connie.slackware.com/~alien/multilib/15.0/slackware64-compat32/ su installpkg *-compat32/*.t?zUsing 32-Bit Software Pre-compiled software can be installed and run as-is. If the software you are running requires a library that is not available, follow these instructions to install it.\nIf you are installing software from souce, first you must run the following command to configure the terminal to use the 32-bit packages (The effect will last until you logout from your shell!):\n. /etc/profile.d/32dev.shIf you are installing software from a SlackBuild or similar, please consider these additional instructions.\nAlternatively… A script to do it all for you may be found in the forums\nFinally Whichever method you use, you need to add gcc* and glibc* to the excludes in /etc/slapt-get/slapt-getrc, whether directly or through the GSlapt interface; otherwise when you do a package upgrade, the new multilib packages will be downgraded to their original, standard versions in the repositories.",
    "description": "Warning Multilib is not officially supported in Salix and it is not recommended. Follow these instructions at your own risk.\nOriginal Source\nIn this guide we will discuss how to install multilib support for 32bit apps on a 64bit Salix. It is based on a ‘full’ version of Salix. The source guide is more in-depth, this guide is only the minimal steps required for Salix. If you are using a more recent Salix version, adjust ‘15.",
    "tags": [],
    "title": "How to Install Multilib",
    "uri": "/user/multilib/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "By default, a new Salix installation supports playback of most free video and audio file file formats. If you want to add support for other, non-free formats, you just have to use the Salix Codecs Installer tool.\nYou can either use the GUI tool:\nMenu -\u003e Multimedia -\u003e Install multimedia codecsor from a terminal, run:\nsudo salix-codecs-installer",
    "description": "By default, a new Salix installation supports playback of most free video and audio file file formats. If you want to add support for other, non-free formats, you just have to use the Salix Codecs Installer tool.\nYou can either use the GUI tool:\nMenu -\u003e Multimedia -\u003e Install multimedia codecsor from a terminal, run:\nsudo salix-codecs-installer",
    "tags": [],
    "title": "How to Play Multimedia Files",
    "uri": "/faq/multimedia/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "Packaging 101 Helping out a FOSS project is a great way to say “thank you” to the core team for all their hard work. Helping out with packaging programs for use in the Distribution is a “twofer” in that you get to know the range of software available for the Distro, and you get to learn how it all hangs together, which is really helpful when things go “belly-up” - which happens to us all at some time or another!\nSo, what’s involved in being a packager? Generally, you must know how to compile programs, how to fix broken compiles, how to write the “build” code, have some idea of the FHS and how it is interpreted under your chosen distro, and some idea of the different architectures out there that run Linux.\nIf you have those skills, then let’s take a look at packaging programs for Salix.\nRead the following. Don’t worry, I’ll wait.\nSubmitting packages for inclusion in the Salix repository The technical details of submission. Packaging Rules The do’s and don’ts of packaging according to Salix. Building Packages with slkbuild Slkbuild is the Salix tool which automates a lot of the package making and necessary ancillary files. Package Categories Classifying the packages you build for Salix. Ah, you’re back.\nConfused? I was (probably still a bit hazy on the finer points, too!)\nHopefully these next sections will help you make sense of the docs you have just read.\nWhat you need to know Salix is a slackware based distribution. Not only that, its packages are backward compatible with a standard Slackware install. And it has several different ways in which you can contribute to the number of packages available to Salix users.\nYou can submit packages you make to the official repository on Sourceforge through the Sourceforge tracker as described in the package submission guidelines linked to above. You can submit a SLKBUILD script to the official repository on Sourceforge (along with a complete package) You can “roll your own” packages and announce them on the Forum page for “Contributions” You can put Slackbuild scripts onto Slackbuilds.org, which, while not Salix specific can be used by Salix as well as the rest of the Slackware users. You might find this confusing - I did, and I am still getting tripped up on 1 \u0026 2!\nTo help you sort this out, you need to know that Salix is a “stable” distribution - by that, I mean that it is released when Slackware is released and it shares a release number with Slackware so there is no confusion. At the time of writing the “stable” slackware release is 14.0, and the “stable” Salix release is 14.0. What this basically means is that the release is “frozen” in that no new packages are added and no version updates are allowed (security and bug fixes are allowed, naturally!).\nAs a user, you can keep up to date by judicious use of the -current branch of the Slackware repositories, but you can also break things badly by doing so. That’s the reason the repositories are frozen between releases - to provide as stable a system as possible. Doing so is neither advised or supported by Salix.\nAround the time that the next release of Slackware is imminent, (the Release Candidate 1 or RC1 scenario) a current repository will be up on the Salix servers (synced to Slackware -current). Any packages submitted at that point will be considered for inclusion in the binary repositories, after they have been tested. Be aware that your package may, instead, be added to the SLKBUILD repository - it all depends on the workload of the packagers at the time.\nAfter the release of the new version, the current repository is taken off-line and no new packages (except those required for an edition release like the LXDE or KDE versions of Salix) are added to the binary repositories. Instead, packages will end up in the SLKBUILD repository. The SLKBUILD repository is usually very small in size. The reason for that is that in order for a package to enter the SLKBUILD repository, it should not be present in the Slackware binary repositories, the Salix binary repositories or the slackbuilds.org repository. Naturally, that doesn’t leave much software that is not already there in one form or another.\nIt should now be evident that Salix draws upon most of the available Slackware friendly repositories and adds to them with their SLKBUILD repos which contain all the ingredients necessary for compiling a working, tested package from source. Admittedly, not as convenient as a pre-compiled package, but with the Sourcery tool its a pretty painless way to add that hard to get program to your system.\nSummary If you are going to package something for any of these end-results, try to make it a program that is not on SlackBuilds.org, isn’t already in the Salix binary repository, isn’t in the SLKBUILDs repo and is not included in the Slackware release.\nIf it is a version bump for a third party program, forget putting it on Salix’s sourceforge system unless the version bump broke something and you have fixed it.\nIf it is a security fix for a third party program and nobody else has fixed it upstream, you should aim for a SlackBuild.org friendly package to help out as many people as possible.\nIf it’s something you want to see the latest version of, then package it for yourself and announce it on the Forum (in the “Contributed Packages” section - see 3 above) so all Salixers can take advantage of it.\nIf it’s an obscure library or a set of programs for a specific interest like music mixing, astro-photography, physics simulations etc, then by all means package them up and announce them on the Contributed Package forum. You might like to consider making SlackBuild friendly scripts for Slackbuilds.org also.\nIf you are looking to take on some of the work of maintaining the builds of core packages, you should really start with producing several packages yourself and announcing them on the forum in the “Contributed Packages” section. This will help the core team decide if and where to slot you into the system - sort of like a C.V. or a practical test.\nAlso, you should decide just how much time and resource you can put in to the job of packager because coming up to release time packagers are under real pressure…",
    "description": "Packaging 101 Helping out a FOSS project is a great way to say “thank you” to the core team for all their hard work. Helping out with packaging programs for use in the Distribution is a “twofer” in that you get to know the range of software available for the Distro, and you get to learn how it all hangs together, which is really helpful when things go “belly-up” - which happens to us all at some time or another!",
    "tags": [],
    "title": "New to Packaging",
    "uri": "/dev/packaging/new-to-packaging/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "These are the package categories for the Salix repositories (some of them might not be actually present, because there are no packages to place in yet):\na - The base system. Contains software to get up and running and have a text editor and basic communications programs ap - Various applications that do not require the X Window System d - Program development tools. Compilers, debuggers, interpreters, and man pages. It’s all here f - FAQs, HOWTOs, and other miscellaneous documentation gnome - Applications and libraries from the Gnome project games - Games :) kde - KDE applications (depending on kdelibs) l - Libraries locale - Localisation Packages lxde - LXDE packages lxqt - LXQt packages mate - MATE Desktop packages n - Networking programs. Daemons, mail programs, telnet, news readers, web servers and so on t - teTeX document formatting system tcl - Tcl/tk packages x - X Window System packages xap - Applications that require X to run xfce - Xfce packages ",
    "description": "These are the package categories for the Salix repositories (some of them might not be actually present, because there are no packages to place in yet):\na - The base system. Contains software to get up and running and have a text editor and basic communications programs ap - Various applications that do not require the X Window System d - Program development tools. Compilers, debuggers, interpreters, and man pages. It’s all here f - FAQs, HOWTOs, and other miscellaneous documentation gnome - Applications and libraries from the Gnome project games - Games :) kde - KDE applications (depending on kdelibs) l - Libraries locale - Localisation Packages lxde - LXDE packages lxqt - LXQt packages mate - MATE Desktop packages n - Networking programs.",
    "tags": [],
    "title": "Package Categories",
    "uri": "/dev/packaging/package-categories/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "If you install packages from third party mirrors or from Slackbuilds you should not wonder if gslapt/slapt-get wants to “upgrade” these packages to an older version again. This is normal behaviour because the package manager actually doesn’t care about the version number. It just wants to bring the same version to your computer that is available in the Salix repositories. Also sometimes it is intended to downgrade packages.\nIf you want to keep your third party package you have to blacklist it in gslapt/slapt-get.\nThe reasoning behind this behavior is that a piece of software/code will never be reliable at detecting which version is an actual upgrade and which is not. That is because there exists no algorithm that will do that. Actually nobody can do that reliably, not for all software anyway.\nNote Quick question: which version of firefox is the newer one, 52.6.0esr or 55.0.3? If your answer is the latter, you’re wrong, 55.0.3 is actually about 6 months older than 52.6.0esr and has several security issues that are fixed in 52.6.0esr.\nBesides, even if there were a magical solution that will detect package upgrades properly, several times it is actually needed to downgrade to a previous version. Think of what would happen if a new version of a package came out, it was uploaded to the repositories, everybody upgraded to it and then a severe security issue was found with it. A lot of cases like this have happened already and in several the proposed short term solution was to downgrade to a previous version that was not affected by the security issue. How would a system that only accepts upgrades force the downgrade?\nSo, what happens is that the package management system decides that whatever version of a package is available in the repositories, is the preferred one (not necessarily the newer one) and it will prompt the user to upgrade to it.",
    "description": "If you install packages from third party mirrors or from Slackbuilds you should not wonder if gslapt/slapt-get wants to “upgrade” these packages to an older version again. This is normal behaviour because the package manager actually doesn’t care about the version number. It just wants to bring the same version to your computer that is available in the Salix repositories. Also sometimes it is intended to downgrade packages.\nIf you want to keep your third party package you have to blacklist it in gslapt/slapt-get.",
    "tags": [],
    "title": "Package Manager Wants to Downgrade Packages",
    "uri": "/faq/package-manager-wants-to-downgrade-packages/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "If you have selected the FULL set of packages when you installed Salix, you don’t need to do anything at all. You will receive notifications in your system tray when they are available.\nIf not, you can just install salix-update-notifier with gslapt or using slapt-get:\nsudo slapt-get -i salix-update-notifierThat will run a service that will check every now and then for package updates in the background and will display a system tray notification icon when there are package updates available in the repositories. By clicking on it, gslapt will be launched directly in upgrade mode where you can review the package upgrades and agree to apply them or not.",
    "description": "If you have selected the FULL set of packages when you installed Salix, you don’t need to do anything at all. You will receive notifications in your system tray when they are available.\nIf not, you can just install salix-update-notifier with gslapt or using slapt-get:\nsudo slapt-get -i salix-update-notifierThat will run a service that will check every now and then for package updates in the background and will display a system tray notification icon when there are package updates available in the repositories.",
    "tags": [],
    "title": "How to Get Notifications for Package Updates",
    "uri": "/faq/package-update-notifications/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "Here is a list of packages, present in both Salix and Slackware repositories and the reasons Salix is using a different build:\nSalix 15.0 elilo: Minor tweaks to eliloconfig. lilo: Salix artwork. Minor tweaks to liloconfig. meson: Newer version so that updated versions of other packages can be built. mozilla-firefox: Using the latest ESR version. sysvinit-scripts: Tweaked for boot speedup. Colorized boot messages. Autostart feature for every executable file in /etc/rc.d/. xfce packages: We offer repositories for Xfce 4.18: i586, x86_64. Salix 14.2 elilo: Minor tweaks to eliloconfig. hplip: No QT GUI. lilo: Salix artwork. Minor tweaks to liloconfig. mozilla-firefox: Using the latest ESR version. sysvinit-scripts: Tweaked for boot speedup. Colorized boot messages. Autostart feature for every executable file in /etc/rc.d/. v4-utils: No QT GUI. wpa_supplicant: No QT GUI. Salix 14.1 elilo: Minor tweaks to eliloconfig. hplip: No QT GUI. lilo: Salix artwork. Minor tweaks to liloconfig. mozilla-firefox: Using the latest ESR version. sysvinit-scripts: Tweaked for boot speedup. Colorized boot messages. Autostart feature for every executable file in /etc/rc.d/. v4-utils: No QT GUI. wpa_supplicant: No QT GUI. Salix 14.0 gst-plugins-good: Many more plugins, that are essential for gstreamer actually being of any use, are included. hplip: No QT GUI. lilo: Salix artwork. Minor tweaks to liloconfig. mozilla-firefox: Using the latest ESR version. p11-kit: Built with support for engine_pkcs11. sqlite: tcl support is broken in the Slackware package (32-bit only) sysvinit-scripts: Tweaked for boot speedup. Colorized boot messages. Autostart feature for every executable file in /etc/rc.d/. v4-utils: No QT GUI. wpa_supplicant: No QT GUI. Salix 13.37 hplip: No QT GUI. libvorbis: Using the aotuv version instead, provides better quality encodes. Fully compatible with the official library version. lilo: Slackware package repackaged with different artwork. Minor tweaks to liloconfig. mozilla-firefox: Using the latest ESR version. shadow: Patched the Slackware package for fixing a bug where the environment was not set correctly with su. sysvinit-scripts: Tweaked for boot speedup. Colorized boot messages. Autostart feature for every executable file in /etc/rc.d/. wicd: The Slackware package is broken. wpa_supplicant: No QT GUI. xfce: Mount vfat devices with thunar using utf8 by default. Salix 13.1 cups: Patched for behaving with gnome-vfs. gst-plugins-good: The Slackware package has no support for using audio/video with a webcam. libvorbis: Using the aotuv version instead, provides better quality encodes. Fully compatible with the official library version. lilo: Slackware package repackaged with different artwork. Minor tweaks to liloconfig. mozilla-firefox: Using the latest ESR version. pkgtools: The pkgtools package is available, but Salix is using spkg as default, however the original pkgtools are included even in the spkg-pkgtools package. Spkg is written in C and is much faster, see their website sc: The slackware package doesn’t really work (x86_64 only) shadow: Patched the Slackware package for fixing a bug where the environment was not set correctly with su. sysvinit-scripts: Tweaked for boot speedup. Colorized boot messages. Autostart feature for every executable file in /etc/rc.d/. hplip: No QT GUI. wavpack: Newer version. wicd: The Slackware package is broken. wpa_supplicant: No QT GUI. xf86-video-intel: Offer both 2.11.0 and 2.9.1 versions of the driver. The older driver is needed for PCs with intel cards that fail to work with KMS with kernel 2.6.33.4. xfce: Patched mousepad for fixing a bug with the Find text tool. Salix 13.0 libvorbis: Using the aotuv version instead, provides better quality encodes. Fully compatible with the official library version. lilo: Slackware package repackaged with different artwork. Minor tweaks to liloconfig. mozilla-firefox: Using the latest ESR version. pkgtools: The pkgtools package is available, but Salix is using spkg as default, however the original pkgtools are included even in the spkg-pkgtools package. Spkg is written in C and is much faster, see their website shared-mime-info: Support for xz compressed files. sysvinit-scripts: Some code added to support splashy at bootup. Autostart feature for every executable file in /etc/rc.d/ added. hplip: No QT GUI. wavpack: Newer version. wicd: The Slackware package is broken. wpa_supplicant: No QT GUI. xfce: Newer exo that fixes several problems. xfce4-power-manager: Newer version. ",
    "description": "Here is a list of packages, present in both Salix and Slackware repositories and the reasons Salix is using a different build:\nSalix 15.0 elilo: Minor tweaks to eliloconfig. lilo: Salix artwork. Minor tweaks to liloconfig. meson: Newer version so that updated versions of other packages can be built. mozilla-firefox: Using the latest ESR version. sysvinit-scripts: Tweaked for boot speedup. Colorized boot messages. Autostart feature for every executable file in /etc/rc.",
    "tags": [],
    "title": "Packages that are Different from Slackware",
    "uri": "/faq/packages-different-from-slackware/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "Packagers are encouraged to also visit the following links:\nBuilding packages with slkbuild Writing A SlackBuild Script Submitting packages for inclusion in the Salix repository Recommended UIDs and GIDs Package rules The package should be named $name-$version-$arch-$packagereleaseXY.txz with a breakdown as below:\n$name: the name of the software and should contain only alphanumeric characters. “-” is supported. $version: the version of the software, ie 1.5.0.6 $arch: i586 in most cases for 32-bit packages, x86_64 for 64-bit packages, noarch for scripts or “resource only” packages (ie : artwork) $packagerelease: Start with 1 and for any subsequent updates to the same version of the package, increase by 1; this includes rebuilding for a new Salix edition. If the package can be transferred without rebuilding, the name remains unchanged. When upgrading to a new version, go back to 1. XY: your initials, so it’s obvious who the packager is. The $version has the following additional restrictions:\nSeparators “-” , “()” are forbidden, “.” is the digit separator that should be normally used Packages compiled from svn sources must be version like “r12345”, where 12345 is the svn commit. All packages shall install without requiring that the user perform postinstallation procedure to render the application usable. Not applicable to server packages of course where configuration should always be done after installation.\nAll packages must contain a valid slack-desc file containing a brief yet accurate description of the package’s contents or application. The slack-desc file must NOT contain the name of the packager NOR the version of the packaged software (these go to the buildscript).\nThe post install script doinst.sh should include only relative paths to / , ie: /etc/profile is addressed as etc/profile in the doinst.sh script.\nAll packages “packagename.txz” shall be accompanied by a file named “packagename.md5” that contains the package’s md5 sum, ie: e16-1.0.1-x86_64-1gv.txz will be shipped with e16-1.0.1-x86_64-1gv.md5\nIf a package “packagename.txz” has any external dependencies then the txz file should be accompanied by a file named “packagename.dep” that includes a comma separated list of dependencies. You can use [[depfinder]] to create that file.\nAll packages compiled for the x86 architecture should be compiled with\nCFLAGS=\"-O2 -march=i586 -mtune=i686\"and/or\nCXXFLAGS=\"-O2 -march=i586 -mtune=i686\"unless a “reasonable” condition exists to do otherwise.\nAll packages compiled for the x86_64 architecture should be compiled with\nCFLAGS=\"-O2 -fPIC\"and/or\nCXXFLAGS=\"-O2 -fPIC\"unless a “reasonable” condition exists to do otherwise.\nPackages should be compiled with the following options:\nconfigure --prefix=/usr --libdir=/usr/lib${LIBDIRSUFFIX} --localstatedir=/var --sysconfdir=/etc --mandir=/usr/manwhere $LIBDIRSUFFIX should be empty for x86 packages and set to “64” for x86_64 packages. This also means that:\nPackages are not allowed to install files in “/opt” and “/usr/local” by any means. “/usr” is the install path prefix log files must be installed in the directory “/var” configuration files must be installed in the directory “/etc” man pages must be placed in “/usr/man” All binaries and system libraries must be stripped of debugging symbols.\nMan pages and Info files must be gziped.\nFiles installed to the directory “/usr/doc” must not have group/world writeable permissions.\nAll X application packages which are supposed to appear in the application menu shall install appropriate “packagename.desktop” files in the “/usr/share/applications” directory.\nAll icons are to be installed in the /usr/share/icons/hicolor/scalable/apps/ or /usr/share/icons/hicolor/SIZExSIZE/apps/ directories depending on the icon type svg or png, where SIZE is the icon size (48x48, 32x32 etc). /usr/share/pixmaps use for menu icons is discouraged but allowed if the app doesn’t function properly otherwise. Internal application images should be placed in /usr/share/app-name/some-directory or /usr/share/pixmaps/app-name (most apps do it this way, btw).\nWindow Managers and Desktop Environments packages must install a .desktop file in /etc/share/xsessions (ie: /etc/X11/dm/Sessions/e16.desktop). A xinitrc file should be placed in the /etc/X11/xinit directory (ie: /etc/X11/xinit/xinit.e16)",
    "description": "Packagers are encouraged to also visit the following links:\nBuilding packages with slkbuild Writing A SlackBuild Script Submitting packages for inclusion in the Salix repository Recommended UIDs and GIDs Package rules The package should be named $name-$version-$arch-$packagereleaseXY.txz with a breakdown as below:\n$name: the name of the software and should contain only alphanumeric characters. “-” is supported. $version: the version of the software, ie 1.5.0.6 $arch: i586 in most cases for 32-bit packages, x86_64 for 64-bit packages, noarch for scripts or “resource only” packages (ie : artwork) $packagerelease: Start with 1 and for any subsequent updates to the same version of the package, increase by 1; this includes rebuilding for a new Salix edition.",
    "tags": [],
    "title": "Packaging rules",
    "uri": "/dev/packaging/packaging-rules/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "slkbuild is a script which makes package creation much easier. It parses a meta file called a SLKBUILD and creates a conventional build-name.sh script and then optionally runs it. It is inspired by the arch build system and greatly simplifies the build process. It is available in the repositories and it is a good idea to have it installed when going through this tutorial. Note that this is not a substitute for knowing how to compile. You still need to know how to compile, you just won’t need to know much more than that to package as this tool generally takes care of the mundane and obscure packaging rules.\nFeatures These are things automatically taken care of by the build script that slkbuild creates not mentioned below.\nPut custom files in /usr/src/$pkgname-$pkgver - Copy source files that don’t contain a URL Untars source tarballs - this is explained below in build() somewhat, but it untars any source tarballs so all you have to do is cd into the untarred directory and do what you need to do to get it into the DESTDIR. See below build() in HOWTO. Cleans old build - sometimes you need to build something more than once and before the build script runs it cleans out all the old stuff Auto downloads source - if you provide the source as a url, the build script is written to automatically download that url if the file is not in the directory already. Sets permissions - makes sure all the standard permissions are set. checks for menu compliance - it makes sure that any Icon= variables in .desktop files don’t have extensions. Strips binaries - finds all the binaries and strips them of symbols Deals with man and info pages - it checks to see if they were installed in /usr/share and if so moves them to /usr so –mandir=/usr/man is no longer necessary and gzips them. Copies over the build script - copies the build-$pkgname.sh script that is created by slkbuild, and the respective SLKBUILD. Creates the package - does the makepkg and calculates the md5sum. Copy .desktop file - copy the .desktop file to usr/share/applications. HOWTO SLKBUILD The first thing you must do is create a proper SLKBUILD and put it in an empty directory. Here is an example (obviously not a real one) with explanations. See man SLKBUILD for explanations or look below.\n#Maintainer: Alfred Zomtec \u003cemail@address.com\u003e #Former Maintainer(s): Thorsten Vlahavas \u003cemail@address.com\u003e #Mandatory pkgname=libdv pkgver=1.0.0 pkgrel=1az arch=i586 source=(\"http://project-xy.net/dl/$pkgname/$pkgname-$pkgver.tar.gz\" \\ \"thing.desktop\" \\ \"anyothersourcestuff\") sourcetemplate=http://my-server.net/packages/$pkgname/ #Optional docs=('authors' 'copying' 'changelog' 'install' 'news' 'readme') url=\"http://libdv.sourceforge.net/\" dotnew=('etc/thing' 'etc/foo' 'etc/bar') options=('noautodotnew') CFLAGS=\"-03 -funrolloops\" CXXFLAGS=\"-03 -funrolloops\" slackdesc=\\ ( #|-----handy-ruler------------------------------------------------------| \"libdv (software codec for DV video)\" \"The Quasar DV codec (libdv) is a software codec for DV video, the\" \"encoding format used by most digital camcorders, typically those that\" \"support the IEEE 1394 (a.k.a. FireWire or i.Link) interface. Libdv was\" \"developed according to the official standards for DV video: IEC 61834\" \"and SMPTE 314M\" ) build() { cd $startdir/src/$pkgname-$pkgver ./configure \\ --prefix=/usr \\ --libdir=/usr/lib${LIBDIRSUFFIX} \\ --localstatedir=/var \\ --sysconfdir=/etc \\ --mandir=/usr/man make || return 1 make DESTDIR=$startdir/pkg install } doinst() { # commands run after installation }Mandatory pkgname - package name, the name of the software: libdv-1.0.0-i586-1az.tgz pkgver - package version, the version of the software: libdv-1.0.0-i586-1az.tgz pkgrel - package release, this is that number at the end of the tgz, including the initials of the packager: libdv-1.0.0-i586-1az.tgz arch - the architecture of the build, usually i586 or noarch, on some occasions i686: libdv-1.0.0-i486-1az.tgz. This is not mandatory and will default to your system’s architecture. You’ll still need to use it for “noarch” packages. source - these are all the files that will be used in the build. You can either put a url which will be downloaded if it isn’t found in the directory. Or you can just put the file like the commented out one below it. If you have more than one file like a patch or an icon just add it to the array like this: source=(“thing.tar.gz” “foo.patch” “bar.icon”). If you don’t specify a url for a file, that file will be copied inside the package, in a /usr/src/$pkgname-$pkgver directory. slackdesc - These are the lines for the slack-desc in the package. Make sure each line is under 70 characters, you can ensure that by following the commented out ruler. Use the general rules for this, the first line has the name and a short description. The lines under it have a longer description. Don’t worry about skipping line 2, the slkbuild does that automatically. Put quotes around each line and make sure you don’t have more than ten lines. All of these rules are checked by the script to make sure they are compliant so don’t be too worried, it will tell you. build() - This is the function that actually creates the package. To understand this, you need to know what the build script does before it runs it. The build script first assigns “pwd” to $startdir. It then creates $startdir/src. It then copies everything in the source=() array into $startdir/src and untars any tarballs. After that it creates $startdir/pkg. Your jobs in build() is to do whatever you need to do in $startdir/src to get $startdir/pkg setup as a DESTDIR. Remember that it automatically untars tarballs, so here what happens is I change into the untarred directory compile and then install into $startdir/pkg. Don’t worry about gzipping and stripping and all of that stuff, it is handled by the build script. Also try to do “make || return 1” so that the build script stops if the compile fails. Optional sourcetemplate - url location where SLKBUILD and build-name.sh can be downloaded. Furthermore all files from source without url must be available at this location. docs - put any of the docs that need to be copied over, readme install changelog, etc. are common ones. Don’t worry about case or path, it does a recursive case insensitive search for them and moves them over when it finds it. options - this is an array which allows you to control certain behaviors of the build script that is generated. The options it takes are ’noextract' which prevents the script from automatically extracting tarballs, this is useful in dealing with tarbombs and some other instances. If you use this, it is necessary to untar any tarballs yourself in build(). The ’nostrip’ option prevents the execution of the stripping function, can be useful in some applications, that break if they are stripped. ’noautodotnew’ is used to remove the automatic dotnew handling in all files in etc. ’tgz’, ’tbz’ and ’tlz’ set the compression format for the resulting package, the default is txz. If you set more than one of ’tgz’, ’tbz’ and ’tlz’, only the first one will be used. whichever is that. url - Homepage or some other information url about the software. dotnew - These are generally configuration files. They will be renamed with a .new extension and the appropriate addition will be made to the doinst.sh to move them over if appropriate to do so during install. doinst() - These are any of the commands (note dotnew stuff is taken care of so don’t put that here) that you want run right after install that won’t be added automatically by makepkg. CXXFLAGS/CFLAGS - You can set these to override the default flags which on 32bits are: -02 -march=$arch -mtune=i686on 64bits they are:\n-O2 -fPIC\" on x86_64,on arm they are:\n-O2 -march=armv5teand in other cases they are:\n-O2 -march=$archwhere $arch is the variable you set in SLKBUILD. Note that if you override it, you need to put all the flags. Like if you just want to change -02 to -03, you would need to put\nCFLAGS=\"-03 -march=$arch -mtune=i686\"and not just\nCFLAGS=\"-03\"How to run slkbuild It’s strongly recommended that you use fakeroot together with slkbuild. This will save your system from possible trouble. See the fakeroot man page how it works. You cd into the directory with the SLKBUILD and all the source files if any and you can do one of the following:\nslkbuild - run with no arguments it creates a conventional build-$pkgname.sh file which you can inspect and then run. slkbuild -c - Remove pkg and src directories slkbuild -x - does the same as slkbuild with no arguments except it executes the build script it creates therefore allowing for all in one packaging. slkbuild -X - Combines -x and -c together slkbuild -g[prototype] - copies a SLKBUILD prototype from /etc/slkbuild into the current directory. It optionally takes a prototype argument which allows you to store multiple prototypes. The prototype argument is actually the extension of the name of the SLKBUILD prototype in /etc/slkbuild. So if you did slkbuild -gpython, it would copy over /etc/slkbuild/SLKBUILD.python. Or if you did slkbuild -gfoo, it would copy over /etc/slkbuild/SLKBUILD.foo. When run with no arguments, just slkbuild -g, it copies over /etc/slkbuild/SLKBUILD. slkbuild -v - print version Man Pages For some different and perhaps more in depth information there are two man pages:\nman SLKBUILD man slkbuild Building packages from git or svn sources Getting git or svn sources for use with slkbuild",
    "description": "slkbuild is a script which makes package creation much easier. It parses a meta file called a SLKBUILD and creates a conventional build-name.sh script and then optionally runs it. It is inspired by the arch build system and greatly simplifies the build process. It is available in the repositories and it is a good idea to have it installed when going through this tutorial. Note that this is not a substitute for knowing how to compile.",
    "tags": [],
    "title": "Building Packages with slkbuild",
    "uri": "/dev/packaging/packaging-with-slkbuild/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "It should be noted that the default kernel that ships with Salix will work in the vast majority of cases, and no recompiling is necessary. You should only recompile if:\nYour system’s hardware (or other feature) is not supported by the default kernel You believe the same kernel can be built with an option to support it To get an extra fraction of a percent hardware performance For fun Before going ahead, it may be easier (and will in many cases be sufficient to solve the problem) to install the kernel from slackware current, which will always be relatively recent. You can see the instructions on how to compile a different kernel release.\nThe procedure is actually quite simple, as long as you remember to reinstall the bootloader before rebooting. However, it can take a long time. Note that the kernel should not be built with root privileges.\nPreparation First, get the kernel source by installing the kernel-source package from Salix repositories, if needed. We will use the 3.2.25 kernel for this example, but substitute that for the kernel version you want.\nMove to the /usr/src/linux-3.2.25 directory (changing 3.2.25 to whichever kernel version applies), and run:\nmake mrproperThis is a cleaning procedure and will set everything to default. You can work from here, but it is highly recommended to use the working configuration (i.e. the one you’ve been running on). The default kernel config is found in /proc/config.gz, so copy this file:\nzcat /proc/config.gz \u003e .configNext, you can configure your kernel. The advantage of using the working configuration as a starting-point is you can leave nearly all the options just as they are.\nTo differentiate the two kernel builds, you need to set a suffix for the kernel version, such as 3.2.25-custom. This can be set in the configuration under General setup, by selecting the option Local version - append to kernel release.\nThere is a choice of interfaces for the configuration. To use a graphical interface, run:\nmake gconfigfor the gtk-based config, or on a KDE system to get a qt interface:\nmake xconfigor finally an ncursers based menu-driven configuration, which will work even if you’re not running X, with::\nmake menuconfigThe number of different options may appear bewildering, but pretty much all of them can (indeed should) be left unchanged from the working configuration. If in doubt, as a rule of thumb, it is probably best to leave it as is.\nCompiling Once you have configured the kernel to your liking, save and exit. Then run:\nmaketo build the kernel. This will take some a long time, depending on how fast your PC is. Average time is probably measured in hours…\nInstalling After compiling is done, run:\nsudo make modules_installto install all of the modules. All of the modules will be installed under /lib/modules/version-custom, where ‘version-custom’ corresponds to the version of the kernel compiled and the suffix you selected.\nNext, copy the created kernel image and system map to the boot directory.\nsudo cp -v arch/x86/boot/bzImage /boot/vmlinuz-version-custom sudo cp -v System.map /boot/System.map-version-customwhere ‘version-custom’ corresponds to the version of the kernel compiled.\nAssuming the kernel in your working system is the standard one that came with Salix, the new one you just built will also be a ‘huge’ kernel that doesn’t need an initrd, so you can omit the next step.\ninitrd However, if you know you do need to create an initrd.gz file:\nsudo /usr/share/mkinitrd/mkinitrd_command_generator.sh -l /boot/vmlinux-versionwill generate a mkinitrd command that you can then copy and paste. By default, it will output to /boot/initrd.gz. You may want to change this when cutting and pasting so that it will output to /boot/initrd-version-custom.gz. Note that a suggested lilo stanza is also created, but the initrd itself is only made when you run the ‘mkinitrd’ command itself.\nAs a final step, edit /etc/lilo.conf so that it will see the newly created kernel, including the ‘initrd’ line only if you created one:\nimage = /boot/vmlinuz-version-custom root = /dev/sda6 initrd = /boot/initrd-version-custom.gz label = \"New Kernel\" read-onlyRefresh LILO Don’t forget to run\nsudo lilo -vto take effect of the new configuration; or use whichever tool you prefer to install the bootloader.\nThat’s it. When you reboot, you should see the new kernel in the lilo menu, and everything should work. As a check, after the system reboots itself:\nuname -aYou should see that the kernel version (with your suffix) is indeed what was just made.\nThe old kernel is still present, and your bootloader will still include an option to boot with it as a fallback. Once you are certain everything is working properly with the new one, you may wish to remove the old entry from the bootloader and (optionally, with care) delete the old kernel in /boot.",
    "description": "It should be noted that the default kernel that ships with Salix will work in the vast majority of cases, and no recompiling is necessary. You should only recompile if:\nYour system’s hardware (or other feature) is not supported by the default kernel You believe the same kernel can be built with an option to support it To get an extra fraction of a percent hardware performance For fun Before going ahead, it may be easier (and will in many cases be sufficient to solve the problem) to install the kernel from slackware current, which will always be relatively recent.",
    "tags": [],
    "title": "How to Rebuild the Slackware Kernel",
    "uri": "/user/rebuild-slackware-kernel/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Salix basic and full installation modes install several xorg packages that are not all needed in any given PC, but are included so Salix works in every possible hardware setup. For example, you don’t need ati or nvidia video drivers if you have an intel video card.\nVideo drivers You probably have only one video card in your PC so you can remove drivers for all video cards you don’t have. To get a list of all installed video drivers, run:\nls /var/log/packages/xf86-video-*Find the one that matches your video card and you can remove all except that one! Keeping xf86-video-vesa might be a good idea though, just to have a working fallback driver in any case.\nInput drivers You also probably don’t need all input drivers. To get a list of them, run:\nls /var/log/packages/xf86-input-*You’ll certainly need xf86-input-keyboard, xf86-input-mouse and xf86-input-evdev. Look in the list for any other hardware you might have and you can remove the rest.\nIBus If you’re not using IBus and anthy to input characters in your native language, then you can remove them with:\nspkg -d /var/log/packages/ibus-* spkg -d anthy fcitx-anthy ibus-anthy",
    "description": "Salix basic and full installation modes install several xorg packages that are not all needed in any given PC, but are included so Salix works in every possible hardware setup. For example, you don’t need ati or nvidia video drivers if you have an intel video card.\nVideo drivers You probably have only one video card in your PC so you can remove drivers for all video cards you don’t have.",
    "tags": [],
    "title": "How to Remove Unnecessary Xorg Packages",
    "uri": "/user/remove-unnecessary-xorg-packages/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "The following mirrors are available for the Salix repositories. Individual directories for every Salix architecture and version are under the following URLs. Users can pick the one that is closest/fastest for them and edit their /etc/slapt-get/slapt-getrc and /etc/slapt-get/slapt-srcrc mirror settings accordingly.\nHTTP http://mirrors.slackware.bg/salix (Bulgaria) http://mirror.its.dal.ca/salix (Canada) http://slackware.uk/salix (England) http://www.mirrorservice.org/sites/download.salixos.org (England) http://download.salixos.org (France) http://salix.enialis.net (France) http://ftp.cc.uoc.gr/mirrors/linux/salix (Greece) http://ftp.heanet.ie/pub/salix (Ireland) http://salix.mirror.garr.it/salix (Italy) http://ftp.nluug.nl/os/Linux/distr/salix (Netherlands) http://ftp.nux.ipb.pt/dists/salix (Portugal) https://mirror.freedif.org/Salix/ (Singapore) https://ftpmirror.infania.net/mirror/salix/ (Sweden) http://ftp.yzu.edu.tw/Linux/salix (Taiwan) http://mirrors.nix.org.ua/linux/salixos (Ukraine) http://mirrors.xmission.com/salix (Utah, US) http://www.gtlib.gatech.edu/pub/salixos (Georgia, US) FTP ftp://mirrors.slackware.bg/salix (Bulgaria) ftp://mirror.its.dal.ca/salix (Canada) ftp://slackware.uk/salix (England) ftp://ftp.mirrorservice.org/sites/download.salixos.org (England) ftp://ftp.cc.uoc.gr/mirrors/linux/salix (Greece) ftp://ftp.heanet.ie/pub/salix (Ireland) ftp://ftp.nluug.nl/pub/os/Linux/distr/salix (Netherlands) ftp://ftpmirror.infania.net/mirror/salix/ (Sweden) ftp://ftp.yzu.edu.tw/Linux/salix/ (Taiwan) ftp://mirrors.nix.org.ua/linux/salixos (Ukraine) ftp://mirrors.xmission.com/salix (Utah, US) ftp://ftp.gtlib.gatech.edu/pub/salixos (Georgia, US) RSYNC The following public rsync servers are available:\nrsync://mirrors.slackware.bg/salix (Bulgaria) rsync://rsync.slackware.uk/salix (England) rsync://rsync.mirrorservice.org/download.salixos.org (England) rsync://salix.enialis.net (France) rsync://ftp.nluug.nl/salix (Netherlands) rsync://mirror.freedif.org/Salix (Singapore) rsync://ftpmirror.infania.net/salix/ (Sweden) rsync://ftp.yzu.edu.tw/Linux/salix (Taiwan) rsync://mirrors.nix.org.ua/salixos (Ukraine) rsync://rsync.gtlib.gatech.edu/salixos (Georgia, US) The main rsync service for the Salix repositories is located at:\nrsync://rsync.salixos.org/salix (France) Please use the main rsync service only if you are mirroring the Salix repositories for the purpose of providing a publicly available mirror.\nRsync can be used to create even more mirrors, following these instructions. If you would like to contribute a public mirror, please contact the Salix developers.",
    "description": "The following mirrors are available for the Salix repositories. Individual directories for every Salix architecture and version are under the following URLs. Users can pick the one that is closest/fastest for them and edit their /etc/slapt-get/slapt-getrc and /etc/slapt-get/slapt-srcrc mirror settings accordingly.\nHTTP http://mirrors.slackware.bg/salix (Bulgaria) http://mirror.its.dal.ca/salix (Canada) http://slackware.uk/salix (England) http://www.mirrorservice.org/sites/download.salixos.org (England) http://download.salixos.org (France) http://salix.enialis.net (France) http://ftp.cc.uoc.gr/mirrors/linux/salix (Greece) http://ftp.heanet.ie/pub/salix (Ireland) http://salix.mirror.garr.it/salix (Italy) http://ftp.nluug.nl/os/Linux/distr/salix (Netherlands) http://ftp.nux.ipb.pt/dists/salix (Portugal) https://mirror.freedif.org/Salix/ (Singapore) https://ftpmirror.infania.net/mirror/salix/ (Sweden) http://ftp.yzu.edu.tw/Linux/salix (Taiwan) http://mirrors.",
    "tags": [],
    "title": "Repository Mirrors",
    "uri": "/user/repository-mirrors/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "For the three different installation modes available, Salix occupies approximately the following amounts of disk space respectively:\nFULL: 2.4GB BASIC: 1.4GB CORE: 840MB So, depending on which installation mode you choose, you need to have a partition with at least that much space available.\nThese sizes are the absolute minimum that you’ll require. You have to account for any extra software you might want to install and of course for all your files.\nYou should have at least some space available for temporary files (in /tmp) and package downloads (in /var/slapt-get). If you want to install extra software you need to make room for those too. You should also consider how much space you want to have available in your /home.",
    "description": "For the three different installation modes available, Salix occupies approximately the following amounts of disk space respectively:\nFULL: 2.4GB BASIC: 1.4GB CORE: 840MB So, depending on which installation mode you choose, you need to have a partition with at least that much space available.\nThese sizes are the absolute minimum that you’ll require. You have to account for any extra software you might want to install and of course for all your files.",
    "tags": [],
    "title": "How Much Disk Space Does Salix Need",
    "uri": "/faq/space/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "If for some reason you messed up your menu in your Fluxbox installation, you can quickly restore it with:\ncp /etc/skel/.fluxbox/menu ~/.fluxbox/Alternatively, if you want to restore all default Fluxbox configuration you can run:\ncp -R /etc/skel/.fluxbox ~/",
    "description": "If for some reason you messed up your menu in your Fluxbox installation, you can quickly restore it with:\ncp /etc/skel/.fluxbox/menu ~/.fluxbox/Alternatively, if you want to restore all default Fluxbox configuration you can run:\ncp -R /etc/skel/.fluxbox ~/",
    "tags": [],
    "title": "Restore Fluxbox Menu",
    "uri": "/user/restore-fluxbox-menu/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "What is a Man Page? The Linux manual pages are the reference documentation of the system user (from the basic user to the administrator via the developer). They include all the commands / functions available in the system. The way to read one is to open a terminal and run:\nman the_command_you_want_to_know_aboutOr if you want to use our GTK manual page viewer:\ngtkman the_command_you_want_to_know_aboutExample man slapt-getThe Salix Man page This manual page allows you to read the minimum vital to use your Salix Operating System. To read it, you can run:\nman salixThis man page is installed by default and is included in the salix-man package.",
    "description": "What is a Man Page? The Linux manual pages are the reference documentation of the system user (from the basic user to the administrator via the developer). They include all the commands / functions available in the system. The way to read one is to open a terminal and run:\nman the_command_you_want_to_know_aboutOr if you want to use our GTK manual page viewer:\ngtkman the_command_you_want_to_know_aboutExample man slapt-getThe Salix Man page This manual page allows you to read the minimum vital to use your Salix Operating System.",
    "tags": [],
    "title": "How to Read the Salix Man Page",
    "uri": "/faq/salix-man-page/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "You can log in SalixLive as user one. The password is also one. User one can use the sudo command to execute commands as the superuser.\nThe root user is disabled by default and therefore you can’t log in as root.\nSalix 14.0 and earlier These are now old and unsupported releases of Salix, but just in case you happen to come across one, here is the relevant information:\nYou log in as user one. If you need to make any changes to the system, you need to become root. The Salix Live non-root username is one with no password. The Salix Live root password is live. ",
    "description": "You can log in SalixLive as user one. The password is also one. User one can use the sudo command to execute commands as the superuser.\nThe root user is disabled by default and therefore you can’t log in as root.\nSalix 14.0 and earlier These are now old and unsupported releases of Salix, but just in case you happen to come across one, here is the relevant information:\nYou log in as user one.",
    "tags": [],
    "title": "SalixLive Passwords",
    "uri": "/faq/salixlive-passwords/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Download the sbopkg package from its homepage The version available at the time of writing this guide is 0.33.2 so we’ll use this for our examples. Adjust appropriately for newer versions.\nOpen a root terminal and install the package:\n# spkg -i sbopkg-0.33.2-noarch-1_cng.tgzOpen the /usr/sbin/sbopkg file with your favorite text editor as root, find the line that reads:\nupgradepkg --reinstall --install-new $OLDPKG%\"$PKG\"and change it to:\nspkg -u --reinstall --install-new $PKGSave the file after editing and exit. You can then run sbopkg from a root terminal:\n# sbopkgThe first time sbopkg is run, some directories need to be created, just press the spacebar when sbopkg asks for their creation. As soon as the sbopkg menu comes up, you’ll have to select the Sync option and then you can use sbopkg normally. This will take some time. It’s a good idea to sync every now and then, in order to get all updates from the slackbuilds.org repository. Make sure you read the sbopkg documentation.\nWarning It should be noted that SlackBuilds at slackbuilds.org assume that you have a full Slackware installation, which is obviously not the case with Salix. As such, expect that some of the SlackBuilds available in slackbuilds.org will require you to install extra software in your Salix system in order for them to work properly. If you get build errors and the software doesn’t compile right, the best thing you can do is view the build logs and see what is missing, install it and try again.",
    "description": "Download the sbopkg package from its homepage The version available at the time of writing this guide is 0.33.2 so we’ll use this for our examples. Adjust appropriately for newer versions.\nOpen a root terminal and install the package:\n# spkg -i sbopkg-0.33.2-noarch-1_cng.tgzOpen the /usr/sbin/sbopkg file with your favorite text editor as root, find the line that reads:\nupgradepkg --reinstall --install-new $OLDPKG%\"$PKG\"and change it to:\nspkg -u --reinstall --install-new $PKGSave the file after editing and exit.",
    "tags": [],
    "title": "How to Use Sbopkg with Salix",
    "uri": "/user/sbopkg/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "What is scrollkeeper? ScrollKeeper is a cataloging system for documentation on open systems. It manages documentation metadata and provides a simple API to allow help browsers to find, sort, and search the document catalog.\nAFAIK nothing beyond the Gnome and KDE help browsers does anything usefull with it.\nHow does it work? Scrollkeeper reads files with meta data (provided in the packages of programs that use this) and templates (provided by the scrollkeeper package). It combines these into a database. This database can in turn be read by the help browsers.\nWhat does this mean for package builders? Packages for programs that provide information through scrollkeeper should contain *.omf files and put these in a directory under ${DEST}/usr/share/omf. If this directory is created, but does not contain any files, then there probably went something wrong in the build process.\nThe make install process for some programs generates a scrollkeeper database under ${DEST}/var/lib/scrollkeeper or ${DEST}/var/scrollkeeper. Since the scrollkeeper database is a system wide resource and system specific, these files should not end up in the package. So the build scripts for programs that do this should contain some command to remove this redundant database.\nThe database on the system where the package will be installed does not update automatically when new files appear under /usr/share/omf. So the doinst.sh script must take care of updating the scrollkeeper database.\nExample from the gnome-desktop package configure should be run with the –disable-scrollkeeper option\n./configure other-configure-options --disable-scrollkeeperSometimes –disable-scrollkeeper doesn’t work right and files end up in var/scrollkeeper into your packaging directory anyway ($startdir/pkg if you using [[SLKBUILD]]), so in that case you’ll have to remove them manually. In the build script somewhere between (the last) make install and makepkg add:\n# redundant scrollkeeper if [ -d $startdir/pkg/var/scrollkeeper ]; then rm -r $startdir/pkg/var/scrollkeeper fi if [ -d $startdir/pkg/var/lib/scrollkeeper ]; then rm -r $startdir/pkg/var/lib/scrollkeeper fiThe scrollkeeper updating should happen when the package is being installed, so this has to be added in your doinst.sh script:\n# Update the scrollkeeper database (Remove stale pieces) if [ -x usr/bin/scrollkeeper-update ]; then usr/bin/scrollkeeper-update \u003e /dev/null 2\u003e\u00261 fi",
    "description": "What is scrollkeeper? ScrollKeeper is a cataloging system for documentation on open systems. It manages documentation metadata and provides a simple API to allow help browsers to find, sort, and search the document catalog.\nAFAIK nothing beyond the Gnome and KDE help browsers does anything usefull with it.\nHow does it work? Scrollkeeper reads files with meta data (provided in the packages of programs that use this) and templates (provided by the scrollkeeper package).",
    "tags": [],
    "title": "Scrollkeeper and Packaging",
    "uri": "/dev/packaging/scrollkeeper/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Alpine is basically the same application as Pine, which used to be widely used on university computer sytems around the world. It is a text-based console email client which is very easy to learn and use, and many people prefer it to webmail or graphical email clients. There must be hundreds of quick guides to using Alpine with Gmail. This is simply one way of doing it, with the merit that it actually works for Salix.\nFirst, make sure your Gmail account is set to use IMAP. Almost certainly, it is already.\nAlpine’s configuration file is ~/.pinerc. You can use Alpine’s menus to change the configuration, but it may be easier to edit the file directly. Back it up first.\nAssuming your account is your.name@gmail.com, change these settings from their defaults as follows:\npersonal-name=your.name user-domain=gmail.com smtp-server=smtp.gmail.com/novalidate-cert/tls/user=your.name@gmail.com inbox-path={imap.gmail.com/novalidate-cert/ssl/user=your.name@gmail.com}inboxMany guides tell you to specify the ports:\nsmtp-server=smtp.gmail.com:587/novalidate-cert/tls/user=your.name@gmail.com inbox-path={imap.gmail.com:993/novalidate-cert/ssl/user=your.name@gmail.com}inboxbut this doesn’t seem to be necessary. There is a problem with certificate authentication, and if ’novalidate-cert’ isn’t there, Alpine keeps asking you whether you mind. If you do mind, maybe a solution can be developed along these lines.\nMake sure the feature-list includes the following items as set:\nenable-incoming-folders enable-incoming-folders-checking… and that’s basically it. Alpine is highly configurable. Here are a few more features I use:\ncontinue-tab-without-confirm # the next few eliminate tedious confirmation requests expunge-without-confirm quit-without-confirm no-check-newmail-when-quitting enable-search-and-replace enable-alternate-editor-implicitlyThis last one means you get the editor of your choice instead of Alpine’s default, but you must also specify it:\neditor=pyroom # substitute your favourite text editorSimilarly:\nimage-viewer=viewnior url-viewers=/usr/bin/firefox #substitute your favourite browserto enable spawning these applications when needed. One annoyance is that you can’t get back to your email client until you close the window and possibly the application. A way round this is to create a script in /usr/local, e.g. vimbrobable2-launch:\n#!/bin/sh /usr/bin/vimprobable2 \"$@\" 2\u003e /dev/null \u0026and make it executable. Then put this in ~/.pinerc:\nurl-viewers=/usr/local/bin/vimprobable2-launchDepending on the specific application, focus may move to the new window or not. With Vimprobable, it does.\nThe .pinerc file is long and extensively commented. If necessary, use search to find the lines you need to change. Everything in bold comes from the file.\nFinally, note that deleting an email has the same effect as archiving it when using the web interface. There’s probably a fix for this, but it is actually in line with the way many people use their Gmail accounts anyway.",
    "description": "Alpine is basically the same application as Pine, which used to be widely used on university computer sytems around the world. It is a text-based console email client which is very easy to learn and use, and many people prefer it to webmail or graphical email clients. There must be hundreds of quick guides to using Alpine with Gmail. This is simply one way of doing it, with the merit that it actually works for Salix.",
    "tags": [],
    "title": "How to Setup Alpine With a Gmail Account",
    "uri": "/user/setup-alpine-with-gmail/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "You can setup a secure basic firewall using the “Uncomplicated Firewall or UFW”.\nsudo slapt-get -i gufwthen\nsudo gufwclick status to “on”. This will setup a deny all incoming and allow all outgoing firewall.\nAlternatively, you can\nsudo slapt-get -i ufw sudo ufw enable sudo ufw default deny sudo ufw deny sshThis method will deny all incoming connections and allow outgoing but also deny ssh connections to further protect your system.\nNote: if you require ssh connections then of course do not block it, if you are not sure what ssh (Secure Shell) is, then block it as it will make the system more secure.\nFor both methods make sure you copy, open /etc/rc.d/rc.local with your favourite editor (for example vi):\nsudo vi /etc/rc.d/rc.localand paste the following into it. This will allow the firewall to start with each boot.\nif [ -x /lib/ufw/ufw-init ]; then /lib/ufw/ufw-init start fiIf you want to check the status of your firewall at any time\nsudo ufw status verbose",
    "description": "You can setup a secure basic firewall using the “Uncomplicated Firewall or UFW”.\nsudo slapt-get -i gufwthen\nsudo gufwclick status to “on”. This will setup a deny all incoming and allow all outgoing firewall.\nAlternatively, you can\nsudo slapt-get -i ufw sudo ufw enable sudo ufw default deny sudo ufw deny sshThis method will deny all incoming connections and allow outgoing but also deny ssh connections to further protect your system.",
    "tags": [],
    "title": "Setup Basic Firewall",
    "uri": "/user/setup-basic-firewall/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "Salix integrates dependency management for packages in its own repositories and those built from slackbuilds.org, whose package list is mirrored by Salix, using slapt-src.\nWhere a package is available from both sources, the Salix package is always preferred, even if it is a less recent version. Should you wish to replace it with a build from source, you will need to do so manually from the slackbuilds.org website, and exclude the package in /etc/slapt-getrc to prevent it being automatically downgraded when you do a general package upgrade.\nHowever, that means if Salix in future offers an even newer version of the package in question, you will need to remove the exclude in order to get it.\nAn alternative would be to change the source line in /etc/slapt-srcrc, but this is not recommended as it means slapt-src/Sourcery would ignore the presence of a package in the Salix repositories by default, but the user would still need to add an exclude to /etc/slapt-getrc, so would need to know. If there is a reason to prefer building from source in a specific case, the user has full control over that option.\nFurthermore, switching to the sbo repository would mean losing the benefit of Salix’s dependency management for slackbuilds.",
    "description": "Salix integrates dependency management for packages in its own repositories and those built from slackbuilds.org, whose package list is mirrored by Salix, using slapt-src.\nWhere a package is available from both sources, the Salix package is always preferred, even if it is a less recent version. Should you wish to replace it with a build from source, you will need to do so manually from the slackbuilds.org website, and exclude the package in /etc/slapt-getrc to prevent it being automatically downgraded when you do a general package upgrade.",
    "tags": [],
    "title": "Slackbuilds in Salix Repositories",
    "uri": "/user/slackbuilds-in-salix-repos/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "It is recommended that you use slapt-get/gslapt and not slackpkg. slackpkg is a package manager that was designed to manage packages from a single Slackware repository only.\nUsing slackpkg in Salix could cause (at least) some Salix (customized packages) to be replaced with their Slackware counterparts, which would remove the Salix customizations. Worse case scenario you could end up removing all Salix packages resulting in a mostly unusable system.",
    "description": "It is recommended that you use slapt-get/gslapt and not slackpkg. slackpkg is a package manager that was designed to manage packages from a single Slackware repository only.\nUsing slackpkg in Salix could cause (at least) some Salix (customized packages) to be replaced with their Slackware counterparts, which would remove the Salix customizations. Worse case scenario you could end up removing all Salix packages resulting in a mostly unusable system.",
    "tags": [],
    "title": "Can I Use slackpkg in Salix?",
    "uri": "/faq/slackpkg/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "Recommended UID/GIDs The recommended UID/GIDs for use with SLKBUILD scripts are the same as [the ones for slackbuilds.org](https://slackbuilds.org/uid_gid.txt Defaults Slackware UID/GIDs) in order to avoid conflicts with packages build from SBo.\nExtra This previous list is maintained by the SBo team. If you build a package that is not on that list, we can discuss about it on the mailing list.\nWarning Note that recommended UID/GIDs should not be created automatically when the user installs a package.\nAll informations have to be written in a README.Slackware file which will be in the /usr/doc/$pkgname-$pkgver directory, the user will have to add specific UID/GIDs to his system by hands. A little note in the slack-desc can be usefull.",
    "description": "Recommended UID/GIDs The recommended UID/GIDs for use with SLKBUILD scripts are the same as [the ones for slackbuilds.org](https://slackbuilds.org/uid_gid.txt Defaults Slackware UID/GIDs) in order to avoid conflicts with packages build from SBo.\nExtra This previous list is maintained by the SBo team. If you build a package that is not on that list, we can discuss about it on the mailing list.\nWarning Note that recommended UID/GIDs should not be created automatically when the user installs a package.",
    "tags": [],
    "title": "UIDs and GIDs to use with slkbuild",
    "uri": "/dev/packaging/uid-gid/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation",
    "content": "Upload file releases You have to be a project admin to upload files. Then create a shell to sourceforge:\nssh -t USERNAME,salix@shell.sourceforge.net createThis shell will stand for 4 hours. Create the directories needed (if any) under Salix directory:\nmkdir /home/frs/project/s/sa/salix/NEW_DIRECTORYUpload the files using scp:\nscp MY_RELEASE.iso USERNAME,salix@shell.sourceforge.net:/home/frs/project/s/sa/salix/NEW_DIRECTORY/Make sure new folders are group writeable, so other project admins can add/delete files to the new folder, too. Finally, announce the release in the announcements forum or wherever you like ;-)",
    "description": "Upload file releases You have to be a project admin to upload files. Then create a shell to sourceforge:\nssh -t USERNAME,salix@shell.sourceforge.net createThis shell will stand for 4 hours. Create the directories needed (if any) under Salix directory:\nmkdir /home/frs/project/s/sa/salix/NEW_DIRECTORYUpload the files using scp:\nscp MY_RELEASE.iso USERNAME,salix@shell.sourceforge.net:/home/frs/project/s/sa/salix/NEW_DIRECTORY/Make sure new folders are group writeable, so other project admins can add/delete files to the new folder, too. Finally, announce the release in the announcements forum or wherever you like ;-)",
    "tags": [],
    "title": "How to Work with Sourceforge",
    "uri": "/dev/work-with-sourceforge/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "A user might need the ability of login to a remote machine without typing password each time. First you need to generate a public authentication key:\nGenerating authentication keys Use this command on a machine you want to login from:\nssh-keygen -t rsathe output looks like this (empty passphrase was used):\nuser@host1 $ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/user/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/user/.ssh/id_rsa. Your public key has been saved in /home/user/.ssh/id_rsa.pub.there will also be a hexadecimal key fingerprint and the key’s randomart image. Anyway your public key is /home/user/.ssh/id_rsa.pub.\nCopy the key to remote host Now you have to copy the public key to the remote host you want to be able to login without a password. You can do it manually: create the file ~/.ssh/authorized_keys (if it is not already there) and append the contents of the public key to it. The other way is to use the dedicated tool:\nssh-copy-id -i ~/.ssh/id_rsa.pub user@remote.hostNext login into the remote host, check if the file ~/.ssh/authorized_keys contains your key, then make sure the permissions are as follows:\nchmod 700 ~/.ssh/ chmod 640 ~/.ssh/authorized_keysThen you should be able to login via ssh without pasword, like this:\nssh user@remote.hostUsing different keys for different servers You can use different keys for different servers to increase security and also specify your e-mail address:\nuser@host1 $ **ssh-keygen -t rsa -C \"my@email.com\"** Generating public/private rsa key pair. Enter file in which to save the key (/home/user/.ssh/id_rsa): **/home/user/.ssh/id_rsa.example.com** Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/user/.ssh/id_rsa. Your public key has been saved in /home/user/.ssh/id_rsa.pub.To automatically chose the right key create the file ~/.ssh/config and add something like this:\nHost example.com IdentityFile ~/.ssh/id_rsa.example.com Host github.com IdentityFile ~/.ssh/id_rsa.github.com",
    "description": "A user might need the ability of login to a remote machine without typing password each time. First you need to generate a public authentication key:\nGenerating authentication keys Use this command on a machine you want to login from:\nssh-keygen -t rsathe output looks like this (empty passphrase was used):\nuser@host1 $ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/user/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/user/.",
    "tags": [],
    "title": "How to Login with SSH Without a Password",
    "uri": "/user/ssh-without-password/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "If you have installed another Window Manager for your system, like Fluxbox, you may find that it may not appear in your Login Screen Menu in LightDM, or any other Display Manager you may be using.\nThis is because some window manager packages may not include the proper support for that. For example, Fluxbox is such a package. It is a package provided by Slackware and does not include what is needed to create a menu entry for your Display Manager. You can fix this issue and start your preferred Window Manager in two ways.\nUse the configured xwmconfig WM You may select your preferred Window Manager by running:\nxwmconfig(you don’t need to run this as root or with sudo)\nAfter that, at the login screen, just select the “Xsession default” option. Whichever Window Manager you have configured with xwmconfig will be started.\nAdd custom menu entry You can also add a custom menu entrty yourself by creating a file in /usr/share/xessions. For the Fluxbox example, this could be a/usr/share/xsessions/fluxbox.desktop file with the following contents:\n[Desktop Entry] Encoding=UTF-8 Type=XSession Name=Fluxbox Exec=dbus-launch /etc/X11/xinit/xinitrc.fluxbox Icon=fluxboxNext time you will get to the login screen, Fluxbox will be available as an option.\nThe process should be the same for any other Window Manager that is missing a menu entry. Just look in the /etc/X11/xinint/ directory to find the respective xinitrc file to use.",
    "description": "If you have installed another Window Manager for your system, like Fluxbox, you may find that it may not appear in your Login Screen Menu in LightDM, or any other Display Manager you may be using.\nThis is because some window manager packages may not include the proper support for that. For example, Fluxbox is such a package. It is a package provided by Slackware and does not include what is needed to create a menu entry for your Display Manager.",
    "tags": [],
    "title": "Start Your Window Manager from the Login Screen Menu",
    "uri": "/user/start-wm-from-login-screen/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation \u003e Packaging Documentation",
    "content": "What you should do before submitting packages You should register in the Salix-main mailing list. All development discussions are taking place there.\nWhat packages to submit Feel free to submit packages for any open source software you like. Replacing Slackware packages is generally not accepted, unless there is a really important reason.\nYou can also package proprietary software, provided re-distribution of that software is allowed (like for example the opera web browser).\nWhen to submit packages When preparing for the next Salix release, a “current” repository will be available in the Salix servers, which will be in sync with Slackware’s own “current” repository. A Salix “current” repository generally appears around the time Slackware’s current repository reaches RC1 state. Any packages you submit at that point will be considered for inclusion in the Salix binary repositories. However, there might be cases where the packages will be added to the Salix slkbuild repository instead, depending on the Salix developers' workload.\nAfter a new Salix release is made, the “current” repository will be taken offline and new packages will no longer be accepted in the Salix binary repositories. Any packages you submit at that point, will only be considered for inclusion in the Salix slkbuild repository. The exclusion to that rule, is if a package is needed for a Salix edition release and it’s not already part of the binary repositories; these packages will be considered for inclusion in the Salix binary repositories anyway. You should make sure that any package you submit for inclusion in the Salix slkbuild repository is not already available through slackbuilds.org. If it is, it will only be accepted if there is a really important reason to replace the slackbuilds.org package.\nWhere to submit packages If you would like to submit a package for inclusion in the Salix repository, please create a new ticket in our [http://sourceforge.net/p/salix/packages/ SourceForge ticket system.] You will need to have a SourceForge account before you can login and submit a new ticket, or you can use [http://openid.net/ openid] to log in to SourceForge instead.\nWhen submitting a package, please specify the submission type:\nNew: if the package was not previously present at all in the repos Upgrade: if an older version of the package is already part of the repos (or the previous version repos) and you want to submit a new version * “Rebuild”: if the package currently in the repos is not working and you want to submit a rebuild of the same version Transfer: if the package should be simply transferred from the previous Salix version repos. This can only be used in the case that a new upstream version is not available and the package in the previous Salix version works as it is, with no changes, in the new Salix version. You should test it yourself first if it does. In any case, you’ll probably have to recalculate dependencies for the new Salix version. You must also specify the Salix version(s) this package is aimed at by typing in the appropriate field.\nWhat to include in the bug report When submitting a new package in the bugtracker, please include the following:\na link to the project’s homepage link to “txz” package link to “md5” checksum link to “dep” file that includes dependency info, if there are any dependencies (you can create one with depfinder). You can skip this file if the package you are submitting has no external dependencies. links to all source files you used to create the package. That includes a link to the source tarball(s) you have used as well as links to your Slackbuild, buildscript or SLKBUILD you might have used and generally everything that needs to be present in someone’s system so he can recreate the package. Alternatively you can submit an “src” file that includes links to all of the above mentioned source files. Such an src file will be created when using slkbuild and you have specified the “sourcetemplate” variable link to a package build log. If you’re using slkbuild one will be created automatically for you. If you’re using a Slackbuild/buildscript, then you can create one when building your package with: ./foo.Slackbuild 2\u003e\u00261 | tee build-foo.logIf the package you are submitting requires any dependencies that are not yet present in the Salix or Slackware repositories, then you will need to submit those dependencies in the same ticket as well.\nIf you would like a more automated way to create the bugreports for submitting packages, have a look at Shador’s script at the forums\nYou will of course need to have some web space to upload all those files. If you don’t, you can subscribe in the Salix-main mailing list and make a request. You will get an ftp account which you can use to upload your packages.\nWhen will my package be included in the repository? As soon as it gets tested and found to comply with our packaging rules, it will be included in the Salix repository.",
    "description": "What you should do before submitting packages You should register in the Salix-main mailing list. All development discussions are taking place there.\nWhat packages to submit Feel free to submit packages for any open source software you like. Replacing Slackware packages is generally not accepted, unless there is a really important reason.\nYou can also package proprietary software, provided re-distribution of that software is allowed (like for example the opera web browser).",
    "tags": [],
    "title": "Submitting Packages",
    "uri": "/dev/packaging/submitting-packages/"
  },
  {
    "breadcrumb": "Salix Documentation",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e Developer Documentation",
    "content": "Install the Transifex client First you need to install the transifex-client package, so:\nslapt-get -i transifex-clientHow to map local translation files to a Transifex project You should only do this once for each application you have in Transifex. If you’re using several PCs, you should do it once in every PC.\nNavigate to your project’s directory (the one that includes the po directory with all the *.po files)\ncd myprojectInitialize the transifex project locally:\ntx initthis will create a .tx directory inside the project’s directory. Don’t add this directory to the VCS. The first time you run it in your system, it will also ask you for your Transifex username and password and it will store them in a ~/.transifexrc file.\nYou need to map the transifex resource to this local project. The generic command to use in order to do this, inside your projects directory, is:\ntx set --auto-local -r **myproject**.**myapp** --source-language=en --source-file 'po/**myapp**.pot' 'po/\u003clang\u003e.po'You should replace “myproject” and “myapp” with the correct names. myproject is the Transifex project name and this is usually “salix”. myapp is the resource name for each application inside the “salix” project at Transifex.\nSo, for example, for “liveclone”, that command should be:\ntx set --auto-local -r **salix**.**liveclone** --source-language=en --source-file 'po/**liveclone**.pot' 'po/\u003clang\u003e.po'The “” part always stays as it is. Run this command and check the output for errors. This is just a dry run, only to see if there are any errors, it won’t do anything yet. To actually make it work, add “–execute” to the end of the command line:\ntx set --auto-local -r **salix**.**liveclone** --source-language=en --source-file 'po/**liveclone**.pot' 'po/\u003clang\u003e.po' --executeCheck the output for errors too. This should map the local translation files with the ones from Transifex, so from now on, you can push/pull files to/from Transifex.\nHow to pull translation files from Transifex In order to update the local *.po files with the ones from Transifex, you just need to run this inside the project’s directory:\ntx pull Warning Be careful, if the local translations are newer than the ones in Transifex, these will be replaced by their respective versions in Transifex. if you also want to download new translations, if there are any, add the -a switch:\ntx pull -aCheck the output of the command for the po filenames that are new and didn’t exist before. You should not forget to add these new po files to svn:\nsvn add po/newlang.poCheck that the new or updated translation is well-formatted:\nmsgfmt -c po/newlang.poAnd finally upload the updated/new translations to svn:\nsvn commitHow to push translation files to Transifex If you want to inform Transifex about changes in the pot file, you should run:\ntx push -sThis will also update the po files stored in Transifex with the new entries. However, Transifex can also be set to check svn for updates in the pot file and it will auto update all po files with the new entries in the pot file, if any. So, if you have setup Transifex to autoupdate from the pot file, you can skip this.\nIf you want to push the local *.po files to Transifex, run:\ntx push -tTo push only one language (here french), run:\ntx push -t -l fr Warning If the files stored on Transifex are newer than the ones stored locally, they will be replaced. If you’re receiving translations only from Transifex, you should never do this anyway. This should be done, only if you have updated some translations locally and want to upload them to transifex too.",
    "description": "Install the Transifex client First you need to install the transifex-client package, so:\nslapt-get -i transifex-clientHow to map local translation files to a Transifex project You should only do this once for each application you have in Transifex. If you’re using several PCs, you should do it once in every PC.\nNavigate to your project’s directory (the one that includes the po directory with all the *.po files)\ncd myprojectInitialize the transifex project locally:",
    "tags": [],
    "title": "How to Work with Transifex",
    "uri": "/dev/transifex/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "The biggest single upgrade you can make to a PC’s performance is to add a Solid-State-Drive or SSD. Doing so will shorten your boot times, dramatically increase your write-to-disk speed and prolong battery life on a laptop.\nWhen adding the SSD, three factors need balancing:\nSystem performance SSD longevity Data Safety Background SSDs are NAND memory, organised into PAGES, which are organised into BLOCKS. The controller takes care of all the low level details for us, but knowing something about how the controller works can help us get the best out of our new drive.\nSpecifically, a write operation is done on a page, while a delete operation is done on a block, which is not really important until we face a situation where the drive starts to run out of blank pages. Then the drive controller needs to recover some of the deleted pages. And to do so, it first needs to copy into its cache any data on the pages in the block that are not marked for deletion. Once in the cache it needs to update the ones that are marked for deletion, then blank the “real” block, then write the cache copy into the “real” block. As you can imagine, that takes much more time than just writing data to an empty page. This leads to a situation known as “write amplification”, where unnecessary page writes are happening most of the time. And since the number of erase/write cycles has a maximum for each SSD, this situation accelerates us towards that limit.\nAnother factor that comes into play is “wear levelling”, a process that the controller uses to ensure that pages (or their component cells) are used evenly across the drive. Because if your Operating System is continually writing data to the same pages on the SSD, they will quickly reach their erase/write limit and effectively be “dead” and so will your data.\nWear levelling needs free cells to work with, and once your drive fills up, wear levelling doesn’t happen and can lead to a “dead” drive. Again.\nThe good news is that these are known problems and newer SSD controllers are built to handle these situations - with a little help from us.\nSystem Performance Move volatile data off the drive Log files are useful, but only if you read them - generally, logs are consulted when a problem arises. Therefore keeping reams and reams of logs on a desktop machine is probably not necessary, as long as you can read the logs for your current session. So move the logs to another drive, or better yet, into memory by moving ‘/var/log’ into RAM.Note that if you do move the logs into RAM, Gslapt and Sourcery will not “see” any installed packages after a reboot. Lots of programs use the ‘/tmp’ directory for intermediate files and data while working. Most of it is relevant only to your current session - that’s why ‘/tmp’ is cleared on reboot. Move it into RAM. Same for ‘/var/tmp/’. Programs that use on-disk caches like web browsers can write thousands of files to your drive in a short web browsing session. If at all possible, move their caches into RAM. I can’t find a way to do this with midori, but it is possible with Firefox. You will of course lose your cache upon a reboot, so take that into account before doing this. Reduce ‘metadata’ writes There is a lot of updating of metadata involved in a file read or write operation. The access time, the modification time, the extents used, etc, etc. The biggest problem here is the atime or access time parameter - it ensures that for every read from the disk, we do a write. (Don’t ask!). Mount your SSD filesystems with the ’noatime’ mount directive and you will get a performance boost as well as prolonging the life of your SSD. Using a different scheduler for your SSD Without going into too much detail, you can set a different scheduling algorithm for each drive - rotational as well as SSD. Depending on the underlying hardware, a change of scheduler may provide a performance boost. The “deadline” scheduler is the system default (at the moment), but the “noop” scheduler may provide better performance for your circumstances. You can experiment using the following snippet of code: echo \"noop\" \u003e /sys/block/sdb/queue/scheduler(where ‘/dev/sdb’ is your SSD )\nWarning Don’t try this without a backup - while it didn’t harm my system, I was working on an almost empty drive, and making backups before trying this stuff is just plain common sense, right?\nSSD Longevity Use a filesystem that supports the TRIM command. The TRIM command is a command to the SSD controller to mark a page as invalid when the OS has deleted the files’ data in that page. At some point in the future, the drives garbage collection routines will reclaim the page to the free pool. As far as I am aware, all the latest SSDs support the TRIM command.\nFile systems known to support the TRIM command:\nEXT4 Btrfs GFS2 XFS Some user space programs exist to initiate a TRIM command on a drive that supports it, should you be using a file system that does not. See recent versions of hdparm, but beware that its use (for this purpose) will destroy your data.\nWhen first partitioning your SSD, make sure it is “aligned” - meaning that the block size of your filesystem will align with the block size of your partiton. For this to happen, start your first partition 1MB from the start of the drive. This will ensure that data doesn’t cross page boundaries.\nIt is highly unlikely that a TRIM-enabled SSD used with a TRIM enabled filesystem with the TRIM mount option active, on a desktop machine used for ordinary proposes will become unusable due to “wearing out” the memory in a less than reasonable time. Personally, I consider 3 years to be the maximum life of any drive and experience of running many mail servers, web servers and file stores for a large user-base reinforces that figure for me. So if my new SSD lasts 3 years, I will consider that a reasonable time - your mileage may vary, but anything above 3 years I consider a bonus :-)\nData Safety If you use a journalling file system, you may have options about what is actually journaled, and when. In EXT4, we have:\ndata=writeback mode - no data journalling, but metadata is journalled. A crash/recovery cycle can cause incorrect data to be in files updated shortly before the crash. Best performing of all journalling modes, and less writes=longer SSD longevity. data=ordered mode - journals metadata, but “orders” metadata changes with the data blocks into “transactions”. When a write is done, the associated data blocks are written first. This is the default in Linux EXT4, and is a good compromise between performance and data safety. data=journal - all data and metadata is journalled. Sloooow, except when both reading and writing specific data, when it is the best performing of all. If using data=writeback, the “nobh” option will not associate buffer heads with data pages, speeding things up a bit. The “bh” option is on by default.\nThe “barrier” option (also on by default) enforces on-disk ordering of commits, adding a safety factor to volatile disk write caches. If you have a battery backed drive (only ones I have seen are on RAID controllers) you may get a performance boost by using the “nobarrier” mount option.\nThe commit option tells EXT4 to sync its data and metadata every n seconds. The default is 5 seconds. If your disk crashes you will have lost a maximum of 5 seconds of changes, but your file system will be undamaged due to the journal. Very large numbers can give a performance boost, but will increase the amount of changes lost on a crash.\nSo, what’s best for me? Taking all these factors into consideration, and knowing your own work patterns, you should be able to make an informed decision on what needs to be done with your new SSD.\nAs my laptop is used for web browsing, email, and writing, I chose a middle road. I partitioned the disk so that it was aligned, and here is my ‘/etc/fstab’ file for my new SSD:\n/dev/sda2 swap swap defaults 0 0 /dev/sda3 / ext4 defaults,noatime,discard 1 1 /dev/sda1 /boot ext2 defaults,noatime 1 2 #/dev/cdrom /mnt/cdrom auto noauto,owner,ro,comment=x-gvfs-show 0 0 /dev/fd0 /mnt/floppy auto noauto,users,rw,umask=00 0 0 devpts /dev/pts devpts gid=5,mode=620 0 0 proc /proc proc defaults 0 0 tmpfs /dev/shm tmpfs defaults 0 0 tmpfs\t/tmp tmpfs defaults,noatime,mode=1777\t0 0 tmpfs\t/var/tmp\ttmpfs\tdefaults,noatime,mode=1777\t0 0The root partition is mounted with the ’noatime’ and ‘discard’ mount options, signifying no access time update after a file read, and initiating the TRIM command. Note that ‘discard’ is not used on the ‘/boot’ partition because it is ext2, and the TRIM command is not supported by the ext2 filesystem. Also, note the use of ’tmpfs’ for ‘/tmp’, ‘/var/tmp’ and ‘/var/log’ - and all of these are mounted with the noatime directive, but I am fairly sure that its use on a tmpfs is irrelevant - in any event, writes to memory are very fast, so we are not losing much if the “noatime” option does nothing. (more research needed)\nI left the scheduler at “deadline” after noting no real performance gain from the “noop” scheduler, and I did not change the journaling mode from the default, as I am not too happy about data inconsistencies.\nOverall, my 5 year old laptop is now performing better than when it was new.\nAny inaccuracies are down to me (Shanek54).\nFurther reading EXT4 Spec EXT4 Wiki Wear Levellling Excellent (but dated) overview of the “Why buy an SSD?” type ",
    "description": "The biggest single upgrade you can make to a PC’s performance is to add a Solid-State-Drive or SSD. Doing so will shorten your boot times, dramatically increase your write-to-disk speed and prolong battery life on a laptop.\nWhen adding the SSD, three factors need balancing:\nSystem performance SSD longevity Data Safety Background SSDs are NAND memory, organised into PAGES, which are organised into BLOCKS. The controller takes care of all the low level details for us, but knowing something about how the controller works can help us get the best out of our new drive.",
    "tags": [],
    "title": "How to Tune an SSD",
    "uri": "/user/tune-ssd/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation \u003e Upgrading Between Releases",
    "content": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 13.1. Open file /etc/slapt-get/slapt-getrc and change all “13.0” instances to “13.1”. Also make sure the Slackware repositories have an OFFICIAL priority. Example setups are show below:\ni486 architecture SOURCE=http://salix.enialis.net/i486/slackware-13.1/:OFFICIAL SOURCE=http://salix.enialis.net/i486/slackware-13.1/extra/:OFFICIAL SOURCE=http://salix.enialis.net/i486/13.1/:PREFERREDx86_64 architecture SOURCE=http://salix.enialis.net/x86_64/slackware-13.1/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/slackware-13.1/extra/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/13.1/:PREFERREDAfter you make the changes, run\nslapt-get -uUpgrading packages It’s always safer to upgrade your glibc package first:\nslapt-get -i glibcAnd then upgrade all other packages to their new versions:\nslapt-get --upgradeDO NOT use:\nslapt-get --dist-upgradein any case. Although it might seem to be the best option for upgrading to a different version, it really isn’t.\nUpgrade your udev package, it’s locked for upgrades in /etc/slapt-get/slapt-getrc so you have to ask for it explicitly:\nslapt-get -i udevObsolete packages Some packages have been obsoleted and should be removed. Some have been replaced by new packages. You can do this automatically with:\nslapt-get --remove-obsolete --removeCareful, because this will also remove all personal packages that you might have installed, if any. If you want a complete list of the obsolete packages, read the Slackware and Salix changelogs and look for entries marked with “Removed”:\nUpgrading the kernel You don’t need to upgrade your kernel, especially if your hardware is running with no problems with the old kernel. If you want to, be advised that there might be complications if your system includes ATA hard drives. If you system includes SATA hard drives only, you’ll have no such problems.\nIf you do have ATA hard drives, make sure your read the “LIBATA SWITCHOVER” section in the Slackware CHANGES_AND_HINTS.TXT file in any Slackware 13.1 repository, or you’re likely to have your system not booting after the upgrade.\nIf you don’t have any ATA hard drives, run a:\nls /var/log/packages/kernel*to see which kernel packages you have installed and do a slapt-get -i for each one of them.\nIf you have switched to the kernel-generic package instead of the default kernel-huge package, don’t forget to recreate the initrd.gz file which will be needed for booting you upgraded system. If you’re still using the default kernel-huge package, an initrd is not needed anyway and you needn’t be concerned about it.\nAfter upgrading the packages, don’t forget to edit your /etc/lilo.conf file accordingly and run:\nlilo -vto inform the bootloader about the kernel upgrade.\nConfiguration files After doing all the upgrades, run:\ndotnewto accept or reject new configuration files. Make sure that you DO NOT replace your /etc/passwd, /etc/shadow or /etc/group files. If you do, you will lose all users/groups/passwords you have in your system. However, even if you do, you can get the old files back, they will be kept in the same locations, with an .orig suffix.",
    "description": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 13.1. Open file /etc/slapt-get/slapt-getrc and change all “13.0” instances to “13.1”. Also make sure the Slackware repositories have an OFFICIAL priority. Example setups are show below:\ni486 architecture SOURCE=http://salix.enialis.net/i486/slackware-13.1/:OFFICIAL SOURCE=http://salix.enialis.net/i486/slackware-13.1/extra/:OFFICIAL SOURCE=http://salix.enialis.net/i486/13.1/:PREFERREDx86_64 architecture SOURCE=http://salix.enialis.net/x86_64/slackware-13.1/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/slackware-13.1/extra/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/13.1/:PREFERREDAfter you make the changes, run\nslapt-get -uUpgrading packages It’s always safer to upgrade your glibc package first:",
    "tags": [],
    "title": "How to Upgrade Salix 13.0 to 13.1",
    "uri": "/user/upgrading/13.0-to-13.1/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation \u003e Upgrading Between Releases",
    "content": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 13.37. Open file /etc/slapt-get/slapt-getrc and change all “13.1” instances to “13.37”. Also make sure the Slackware repositories have an OFFICIAL priority. Example setups are show below:\ni486 architecture SOURCE=http://salix.enialis.net/i486/slackware-13.37/:OFFICIAL SOURCE=http://salix.enialis.net/i486/slackware-13.37/extra/:OFFICIAL SOURCE=http://salix.enialis.net/i486/13.37/:PREFERREDx86_64 architecture SOURCE=http://salix.enialis.net/x86_64/slackware-13.37/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/slackware-13.37/extra/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/13.37/:PREFERREDAfter you make the changes, run:\nslapt-get -uUpgrading packages The combined spkg-pkgtools package has been removed in Salix 13.37. The original Slackware pkgtools are being used, along with a separate spkg package. So, you’ll need to replace the spkg-pkgtools package with spkg + pkgtools:\nslapt-get -i spkg pkgtools spkg -d spkg-pkgtoolsUpgrade your glibc package:\nslapt-get -i glibcThe upgrade slapt-get itself (along with its dependencies):\nslapt-get -i slapt-getInstall the new util-linux package:\nslapt-get -i util-linux spkg -d util-linux-ngAnd then upgrade all other packages to their new versions:\nslapt-get --upgradeDO NOT use:\nslapt-get --dist-upgradein any case. Although it might seem to be the best option for upgrading to a different version, it really isn’t.\nUpgrade your udev package, it’s locked for upgrades in /etc/slapt-get/slapt-getrc so you have to ask for it explicitly:\nslapt-get -i udevObsolete packages Some packages have been obsoleted and should be removed. Some have been replaced by new packages. You can do this automatically with:\nslapt-get --remove-obsolete --removeCareful, because this will also remove all personal packages that you might have installed, if any. It will also remove any packages that used to be part of the Slackware or Salix repos in 13.1, but are not anymore in 13.37. And it’s never a bad idea to have a look at the Slackware CHANGES_AND_HINTS.TXT file:\nChanges and Hints File for i486 Changes and Hints file for x86_64 One of the major changes in 13.37 is the replacement of the OpenOffice.org office suite with LibreOffice. By running the above mentioned command, OpenOffice.org along with any respective langpacks will be removed. So, in order to get the new LibreOffice package, you’ll need to run:\nslapt-get -i libreofficeand if you have a langpack installed, also run:\nslapt-get -i libreoffice-l10n-YOURLOCALEreplacing ‘YOURLOCALE’ with the respective language code (e.g. fr for French, el for Greek, de for German etc.)\nOne other new package that you might want to install is user-settings-xfce. That package now includes default configuration for newly created users, so if you want new users created after the upgrade to have the default Salix user settings (desktop settings, artwork etc), you should run:\nslapt-get -i user-settings-xfceUpgrading the kernel Run:\nls /var/log/packages/kernel*to see which kernel packages you have installed and do a slapt-get -i for each one of them.\nIf you have switched to the kernel-generic package instead of the default kernel-huge package, don’t forget to recreate the initrd.gz file which will be needed for booting you upgraded system. If you’re still using the default kernel-huge package, an initrd is not needed anyway and you needn’t be concerned about it.\nAfter upgrading the packages, don’t forget to edit your /etc/lilo.conf file accordingly and run:\nlilo -vto inform the bootloader about the kernel upgrade.\nConfiguration files After doing all the upgrades, run:\ndotnewto accept or reject new configuration files. Make sure that you DO NOT replace your /etc/passwd, /etc/shadow or /etc/group files. If you do, you will lose all users/groups/passwords you have in your system. However, even if you do, you can get the old files back, they will be kept in the same locations, with an .orig suffix.\nIf you are starting your system in init 3 (console), instead of init 4 (graphics) and you start the GUI by running ‘startx’, you’d better refresh the xinitrc file in your home directory by running (while in init 3):\nxwmconfigand selecting your preferred Desktop Environment.",
    "description": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 13.37. Open file /etc/slapt-get/slapt-getrc and change all “13.1” instances to “13.37”. Also make sure the Slackware repositories have an OFFICIAL priority. Example setups are show below:\ni486 architecture SOURCE=http://salix.enialis.net/i486/slackware-13.37/:OFFICIAL SOURCE=http://salix.enialis.net/i486/slackware-13.37/extra/:OFFICIAL SOURCE=http://salix.enialis.net/i486/13.37/:PREFERREDx86_64 architecture SOURCE=http://salix.enialis.net/x86_64/slackware-13.37/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/slackware-13.37/extra/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/13.37/:PREFERREDAfter you make the changes, run:\nslapt-get -uUpgrading packages The combined spkg-pkgtools package has been removed in Salix 13.",
    "tags": [],
    "title": "How to Upgrade Salix 13.1 to 13.37",
    "uri": "/user/upgrading/13.1-to-13.37/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation \u003e Upgrading Between Releases",
    "content": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 14.0. Open file /etc/slapt-get/slapt-getrc and change all “13.37” instances to “14.0”. Also make sure the Slackware repositories have an OFFICIAL priority. Example setups are show below:\ni486 architecture SOURCE=http://salix.enialis.net/i486/slackware-14.0/:OFFICIAL SOURCE=http://salix.enialis.net/i486/slackware-14.0/extra/:OFFICIAL SOURCE=http://salix.enialis.net/i486/14.0/:PREFERREDx86_64 architecture SOURCE=http://salix.enialis.net/x86_64/slackware-14.0/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/slackware-14.0/extra/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/14.0/:PREFERRED Warning On occasion, you might find that enialis’ download speeds leave things desired. If you find yourself in such a scenario, feel free to experiment with the other [[Repository mirrors|repositories provided here]]. N.B: It is perfectly safe to stop the process while a package is in the process of being downloaded. On resume/restart, the download starts off where it last left. But, do not stop the process, if a package is in the process of being installed.\nAfter you make the changes, run:\nslapt-get -uslapt-src Although slapt-src has nothing to do with the upgrade process itself, better make sure its repos are pointing to 14.0 so that they work correctly after the installation. Open your /etc/slapt-get/slapt-srcrc and change the SOURCE lines to these ones:\nSOURCE=http://salix.enialis.net/slkbuild/14.0/ SOURCE=http://salix.enialis.net/sbo/14.0/Upgrading packages First upgrade spkg, glibc and make sure you install the new kmod package and openssl-solibs (it also has the old 0.9.8x openssl libraries included). Also you can make sure mtdev is installed:\nslapt-get -i spkg glibc kmod openssl-solibs mtdevThen upgrade slapt-get itself (along with its dependencies):\nslapt-get -i slapt-getAnd then upgrade all other packages to their new versions:\nslapt-get --upgradeDO NOT use:\nslapt-get --dist-upgradein any case. Although it might seem to be the best option for upgrading to a different version, it really isn’t.\nUpgrade your udev package, it’s locked for upgrades in /etc/slapt-get/slapt-getrc so you have to ask for it explicitly:\nslapt-get -i udevAlso udisks is new to 14.0 so you will need to install both udisks and udisks2:\nslapt-get -i udisks udisks2After the upgrade you can also update the previously installed glibc-solibs package:\nslapt-get -i glibc-solibsXfce One of the major changes in 14.0 is the replacement of the single xfce package with many individual packages. If you’re using xfce, to install a full xfce envirnment, run\nslapt-get --install-set xfceMATE Do all the above, and continue below for the kernel and other updates. Finally, add one extra package for retaining the correct look and feel and retain the same look and feel from 13.37. Otherwise, your DE/GUI wil break.\nslapt-get -i clearlooks-phenixratpoison These two additional packages must be installed. If these are omitted/not installed, the vimprobable2 browser completely stops working. Do all the above steps followed by this, and continue below for the kernel and other updates.\nslapt-get -i glib-networking gsettings-desktop-schemasObsolete packages Some packages have been obsoleted and should be removed. Some have been replaced by new packages. You can do this automatically with:\nslapt-get --remove-obsolete --removeCareful, because this will also remove all personal packages that you might have installed, if any. It will also remove any packages that used to be part of the Slackware or Salix repos in 13.37, but are not anymore in 14.0. And it’s never a bad idea to have a look at the Slackware CHANGES_AND_HINTS.TXT file:\nChanges and Hints File for i486 Changes and Hints File for x864_64 Packages that have been removed from Slackware according to the ChangeLog (use this list at your own risk):\nhal hal-info wv2 jre raptor (reinstall raptor2 afterwards) jdk module-init-tools ntfsprogs iwlwifi* rt2860-firmware rt2870-firmware rt61-firmware rt71w-firmware radeon_ucode scripts xaw3d xf86-video-radeonhd xf86-video-sisusb xf86-video-tseng xf86-video-xgiAnd this NOTE: After upgrading, the following obsolete KDE packages should be removed:\nkdeaccessibility kdebase kdebase-runtime kdebase-workspace kdebindings kdeedu kdegraphics kdeutils koffice konq-plugins kopete-cryptography polkit-kde-1 koffice-l10n-*Upgrading the kernel Run:\nls /var/log/packages/kernel*to see which kernel packages you have installed and do a slapt-get -i for each one of them. (Do not include the package version in ).\nIf you have switched to the kernel-generic package instead of the default kernel-huge package, don’t forget to recreate the initrd.gz file which will be needed for booting you upgraded system. If you’re still using the default kernel-huge package, an initrd is not needed anyway and you needn’t be concerned about it.\nAfter upgrading the packages, don’t forget to edit your /etc/lilo.conf file accordingly and run:\nlilo -vto inform the bootloader about the kernel upgrade.\nOn similar note, users running multi-boot systems on GRUB2 must log into the distro that controls the bootloader and re-run\nupdate-grubto inform the bootloader about the kernel upgrade.\nUpdate caches You’ll also need to run this command:\nupdate-allThis updates icon caches, font indexes, desktop and mime databases, pango files, glib schemas etc. You’ll need to run this, or you’ll probably won’t be able to start a graphical environment and even if you do, you’ll probably see garbage instead of readable characters.\nConfiguration files After doing all the upgrades, run:\ndotnewto accept or reject new configuration files. Make sure that you DO NOT replace your /etc/passwd, /etc/shadow or /etc/group files. If you do, you will lose all users/groups/passwords you have in your system. However, even if you do, you can get the old files back, they will be kept in the same locations, with an .orig suffix.\nIf you are starting your system in init 3 (console), instead of init 4 (graphics) and you start the GUI by running ‘startx’, you’d better refresh the xinitrc file in your home directory by running (while in init 3):\nxwmconfigand selecting your preferred Desktop Environment.\nEdit /etc/slackware-version file to fill in:\nSlackware 14.0This is not required but this is used by some apps to show your version (for example grub).",
    "description": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 14.0. Open file /etc/slapt-get/slapt-getrc and change all “13.37” instances to “14.0”. Also make sure the Slackware repositories have an OFFICIAL priority. Example setups are show below:\ni486 architecture SOURCE=http://salix.enialis.net/i486/slackware-14.0/:OFFICIAL SOURCE=http://salix.enialis.net/i486/slackware-14.0/extra/:OFFICIAL SOURCE=http://salix.enialis.net/i486/14.0/:PREFERREDx86_64 architecture SOURCE=http://salix.enialis.net/x86_64/slackware-14.0/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/slackware-14.0/extra/:OFFICIAL SOURCE=http://salix.enialis.net/x86_64/14.0/:PREFERRED Warning On occasion, you might find that enialis’ download speeds leave things desired. If you find yourself in such a scenario, feel free to experiment with the other [[Repository mirrors|repositories provided here]].",
    "tags": [],
    "title": "How to Upgrade Salix 13.37 to 14.0",
    "uri": "/user/upgrading/13.37-to-14.0/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation \u003e Upgrading Between Releases",
    "content": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 14.1. Open file /etc/slapt-get/slapt-getrc and change all “14.0” instances to “14.1”. Also make sure the Slackware repositories have an OFFICIAL priority. Example setups are show below:\ni486 architecture SOURCE=http://salix.hostingxtreme.com/i486/slackware-14.1/:OFFICIAL SOURCE=http://salix.hostingxtreme.com/i486/slackware-14.1/extra/:OFFICIAL SOURCE=http://salix.hostingxtreme.com/i486/14.1/:PREFERREDx86_64 architecture SOURCE=http://salix.hostingxtreme.com/x86_64/slackware-14.1/:OFFICIAL SOURCE=http://salix.hostingxtreme.com/x86_64/slackware-14.1/extra/:OFFICIAL SOURCE=http://salix.hostingxtreme.com/x86_64/14.1/:PREFERREDChanging your mirrors Feel free to try other repositoriy mirrors that might be faster for you. N.B: It is perfectly safe to stop the process while a package is in the process of being downloaded. On resume/restart, the download starts off where it last left. But, do not stop the process, if a package is in the process of being installed.\nAfter you make the changes, run\nslapt-get -uslapt-src Although slapt-src has nothing to do with the upgrade process itself, better make sure its repos are pointing to 14.1 so that they work correctly after the installation. Open your /etc/slapt-get/slapt-srcrc and change the SOURCE lines to these ones:\nSOURCE=http://salix.hostingxtreme.com/slkbuild/14.1/ SOURCE=http://salix.hostingxtreme.com/sbo/14.1/Upgrading packages First upgrade glibc:\nslapt-get -i glibcThen upgrade slapt-get itself (along with its dependencies):\nslapt-get -i slapt-getThen upgrade libffi (previous version is incompatible to the 14.1 packages and most will fail to upgrade successfully):\nslapt-get -i libffiAnd then upgrade all other packages to their new versions:\nslapt-get --upgradeDO NOT use:\nslapt-get --dist-upgradein any case. Although it might seem to be the best option for upgrading to a different version, it really isn’t.\nUpgrade your udev package, it’s locked for upgrades in /etc/slapt-get/slapt-getrc so you have to ask for it explicitly:\nslapt-get -i udevGrub(2) If you’re not using the default LILO bootloader but instead you have manually installed and are using grub, the grub2 package in 14.0 is now named grub. So you first need to remove the grub2 package:\nslapt-get --remove grub2And then install the grub package on it:\nslapt-get -i grubUse dotnew to deal with files in /etc/grub.d/ directory. Be sure that there are not any .new or .orig files when upgrading the grub.cfg file with the update-grub command.\nXfce The Terminal package that was in 14.0 has now been renamed to xfce4-terminal, so if you want it, you need to install it separately:\nslapt-get -i xfce4-terminalAtril replaces Evince and is in the mate-document-viewer package:\nslapt-get -i mate-document-viewerObsolete packages Some packages have been obsoleted and should be removed. Some have been replaced by new packages. You can do this automatically with:\nslapt-get --remove-obsolete --removeCareful, because this will also remove all personal packages that you might have installed, if any. It will also remove any packages that used to be part of the Slackware or Salix repos in 14.0, but are not anymore in 14.1. And it’s never a bad idea to have a look at the Slackware CHANGES_AND_HINTS.TXT file:\nChanges and Hints File for i486 Changes and Hints File for x864_64 ktsuss/gksu In Salix 14.1, the default backend to gain superuser privileges is sudo, instead of su that we previously used. If you are upgrading from 14.0, you can still continue using su and the ktsuss package as you did before, so you can skip this section.\nIf you want to switch, or additionaly use the sudo backend, just install the wheel-sudo package\nslapt-get -i wheel-sudoand also make sure the user you want to grant superuser privileges with sudo is a member of the wheel group.\nIf you want to use the user’s password (through the sudo backend), instead of the root user’s password, when launching something from the menus, just install the gnsu package. It will replace the ktsuss package.\nslapt-get -i gnsuUpgrading the kernel Run:\nls /var/log/packages/kernel*to see which kernel packages you have installed and do a slapt-get -i for each one of them. (Do not include the package version in ).\nIf you have switched to the kernel-generic package instead of the default kernel-huge package, don’t forget to recreate the initrd.gz file which will be needed for booting you upgraded system. If you’re still using the default kernel-huge package, an initrd is not needed anyway and you needn’t be concerned about it.\nAfter upgrading the packages, don’t forget to edit your /etc/lilo.conf file accordingly and run:\nlilo -vto inform the bootloader about the kernel upgrade.\nOn similar note, users running multi-boot systems on GRUB2 must log into the distro that controls the bootloader and re-run\nupdate-grubto inform the bootloader about the kernel upgrade.\nUpdate caches You’ll also need to run this command:\nupdate-allThis updates icon caches, font indexes, desktop and mime databases, pango files, glib schemas etc. You’ll need to run this, or you’ll probably won’t be able to start a graphical environment and even if you do, you’ll probably see garbage instead of readable characters.\nConfiguration files After doing all the upgrades, run:\ndotnewto accept or reject new configuration files. Make sure that you DO NOT replace your /etc/passwd, /etc/shadow or /etc/group files. If you do, you will lose all users/groups/passwords you have in your system. However, even if you do, you can get the old files back, they will be kept in the same locations, with an .orig suffix.\nIf you are starting your system in init 3 (console), instead of init 4 (graphics) and you start the GUI by running ‘startx’, you’d better refresh the xinitrc file in your home directory by running (while in init 3):\nxwmconfigand selecting your preferred Desktop Environment.\nEdit /etc/slackware-version file to fill in:\nSlackware 14.1This is not required but this is used by some apps to show your version (for example grub).",
    "description": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 14.1. Open file /etc/slapt-get/slapt-getrc and change all “14.0” instances to “14.1”. Also make sure the Slackware repositories have an OFFICIAL priority. Example setups are show below:\ni486 architecture SOURCE=http://salix.hostingxtreme.com/i486/slackware-14.1/:OFFICIAL SOURCE=http://salix.hostingxtreme.com/i486/slackware-14.1/extra/:OFFICIAL SOURCE=http://salix.hostingxtreme.com/i486/14.1/:PREFERREDx86_64 architecture SOURCE=http://salix.hostingxtreme.com/x86_64/slackware-14.1/:OFFICIAL SOURCE=http://salix.hostingxtreme.com/x86_64/slackware-14.1/extra/:OFFICIAL SOURCE=http://salix.hostingxtreme.com/x86_64/14.1/:PREFERREDChanging your mirrors Feel free to try other repositoriy mirrors that might be faster for you. N.B: It is perfectly safe to stop the process while a package is in the process of being downloaded.",
    "tags": [],
    "title": "How to Upgrade Salix 14.0 to 14.1",
    "uri": "/user/upgrading/14.0-to-14.1/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation \u003e Upgrading Between Releases",
    "content": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 14.2. Open file /etc/slapt-get/slapt-getrc and change all “14.1” instances to “14.2”. Also make sure the Slackware repositories have an OFFICIAL priority. Make sure you add the new extra repository, with an OFFICIAL priority too. Example setups are shown below:\ni486 architecture SOURCE=http://slackware.uk/salix/i486/slackware-14.2/:OFFICIAL SOURCE=http://slackware.uk/salix/i486/slackware-14.2/extra/:OFFICIAL SOURCE=http://slackware.uk/salix/i486/14.2/:PREFERRED SOURCE=http://slackware.uk/salix/i486/extra-14.2/:OFFICIALx86_64 architecture SOURCE=http://slackware.uk/salix/x86_64/slackware-14.2/:OFFICIAL SOURCE=http://slackware.uk/salix/x86_64/slackware-14.2/extra/:OFFICIAL SOURCE=http://slackware.uk/salix/x86_64/14.2/:PREFERRED SOURCE=http://slackware.uk/salix/x86_64/extra-14.2/:OFFICIALslapt-srcrc Also edit your /etc/slapt-get/slapt-srcrc file to point to 14.2 instead of 14.1:\nBUILDDIR=/usr/src/slapt-src PKGEXT=txz SOURCE=http://slackware.uk/salix/slkbuild/14.2/ SOURCE=http://slackware.uk/salix/sbo/14.2/Switch to root user Every command listed below should be executed with root privileges. So run:\nsudo suor alternatively, if you have the root user enabled:\nsuto open a root terminal.\nChanging your mirrors Feel free to try other repositoriy mirrors that might be faster for you. N.B: It is perfectly safe to stop the process while a package is in the process of being downloaded. On resume/restart, the download starts off where it last left. But, do not stop the process, if a package is in the process of being installed.\nAfter you make the changes, run\nslapt-get -uslapt-src Although slapt-src has nothing to do with the upgrade process itself, better make sure its repos are pointing to 14.2 so that they work correctly after the installation. Open your /etc/slapt-get/slapt-srcrc and change the SOURCE lines to these ones:\nSOURCE=http://slackware.uk/salix/slkbuild/14.2/ SOURCE=http://slackware.uk/salix/sbo/14.2/Upgrading packages First you need to upgrade glibc. glibc-zoneinfo and glibc-i18n have been split off from the main glibc package in 14.2, so as well as upgrading the main package, you’ll have to install those too:\nslapt-get -i glibc glibc-zoneinfo glibc-i18nThen upgrade slapt-get itself (along with its dependencies):\nslapt-get -i slapt-getAnd then upgrade all other packages to their new versions:\nslapt-get --upgradeDO NOT use:\nslapt-get --dist-upgradein any case. Although it might seem to be the best option for upgrading to a different version, it really isn’t.\nThe procps and ConsoleKit packages have been replaced by alternative implementations, so you’ll need to install them:\nslapt-get -i procps-ng ConsoleKit2If you have a printer installed, you’ll probably need the new cups-filters package:\nslapt-get -i cups-filtersSince the default audio output has been switched to PulseAudio with this release, you probably need a volume controller for it:\nslapt-get -i pavucontrolIf you had engrampa and atril installed (the default archive manager and pdf viewer in most editions, respectively), the package names have changed, so you will need to install the packages with the new names:\nslapt-get -i engrampa slapt-get -i atrilObsolete packages Some packages have been obsoleted and should be removed. Some have been replaced by new packages. One of them is udev and you’ll have to remove it separately:\nspkg -d udevYou can remove all the rest obsolete packages automatically with:\nslapt-get --remove-obsolete --removeCareful, because this will also remove all personal packages that you might have installed, if any. It will also remove any packages that used to be part of the Slackware or Salix repos in 14.1, but are not anymore in 14.2. Take a careful look at the list of packages to be removed and if you recognise anything that you want to keep, make a note. It might have been renamed to something slightly different or it may be available as a binary package in the new release, so you might have to build it using a SlackBuild (with spi, slapt-src or sourcery) later. And it’s never a bad idea to have a look at the Slackware CHANGES_AND_HINTS.TXT file:\nChanges and Hints File for i486 Changes and Hints File for x864_64 Upgrading the kernel Run:\nls /var/log/packages/kernel*to see which kernel packages you have installed and do a slapt-get -i for each one of them. (Do not include the package version in ).\nIf you have switched to the kernel-generic package instead of the default kernel-huge package, don’t forget to recreate the initrd.gz file which will be needed for booting you upgraded system. If you’re still using the default kernel-huge package, an initrd is not needed anyway and you needn’t be concerned about it.\nAfter upgrading the packages, don’t forget to edit your /etc/lilo.conf file accordingly and run:\nlilo -vto inform the bootloader about the kernel upgrade.\nOn similar note, users running multi-boot systems on GRUB2 must log into the distro that controls the bootloader and re-run\nupdate-grubto inform the bootloader about the kernel upgrade.\nFor those using elilo, you just need to copy the new kernel and initrd (if using kernel-generic) to appropriate directory in the ESP:\ncp /boot/vmlinuz /boot/efi/EFI/Salix/vmlinuz cp /boot/initrd.gz /boot/efi/EFI/Salix/initrdUpdate caches You’ll also need to run this command:\nupdate-allThis updates icon caches, font indexes, desktop and mime databases, pango files, glib schemas etc. You’ll need to run this, or you’ll probably won’t be able to start a graphical environment and even if you do, you’ll probably see garbage instead of readable characters.\nConfiguration files After doing all the upgrades, run:\ndotnewto accept or reject new configuration files. Make sure that you DO NOT replace your /etc/passwd, /etc/shadow or /etc/group files. If you do, you will lose all users/groups/passwords you have in your system. However, even if you do, you can get the old files back, they will be kept in the same locations, with an .orig suffix.\nIf you are starting your system in init 3 (console), instead of init 4 (graphics) and you start the GUI by running ‘startx’, you’d better refresh the xinitrc file in your home directory by running (while in init 3):\nxwmconfigand selecting your preferred Desktop Environment.\nEdit /etc/slackware-version file to fill in:\nSlackware 14.2This is not required but this is used by some apps to show your version (for example grub).",
    "description": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 14.2. Open file /etc/slapt-get/slapt-getrc and change all “14.1” instances to “14.2”. Also make sure the Slackware repositories have an OFFICIAL priority. Make sure you add the new extra repository, with an OFFICIAL priority too. Example setups are shown below:\ni486 architecture SOURCE=http://slackware.uk/salix/i486/slackware-14.2/:OFFICIAL SOURCE=http://slackware.uk/salix/i486/slackware-14.2/extra/:OFFICIAL SOURCE=http://slackware.uk/salix/i486/14.2/:PREFERRED SOURCE=http://slackware.uk/salix/i486/extra-14.2/:OFFICIALx86_64 architecture SOURCE=http://slackware.uk/salix/x86_64/slackware-14.2/:OFFICIAL SOURCE=http://slackware.uk/salix/x86_64/slackware-14.2/extra/:OFFICIAL SOURCE=http://slackware.uk/salix/x86_64/14.2/:PREFERRED SOURCE=http://slackware.uk/salix/x86_64/extra-14.2/:OFFICIALslapt-srcrc Also edit your /etc/slapt-get/slapt-srcrc file to point to 14.",
    "tags": [],
    "title": "How to Upgrade Salix 14.1 to 14.2",
    "uri": "/user/upgrading/14.1-to-14.2/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation \u003e Upgrading Between Releases",
    "content": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 15.0. Open file /etc/slapt-get/slapt-getrc and change all “14.2” instances to “15.0”. Also make sure the Slackware repositories have an OFFICIAL priority. Example setups are shown below:\ni486 architecture SOURCE=http://slackware.uk/salix/i486/slackware-15.0/:OFFICIAL SOURCE=http://slackware.uk/salix/i486/slackware-15.0/extra/:OFFICIAL SOURCE=http://slackware.uk/salix/i486/15.0/:PREFERRED SOURCE=http://slackware.uk/salix/i486/extra-15.0/:OFFICIALx86_64 architecture SOURCE=http://slackware.uk/salix/x86_64/slackware-15.0/:OFFICIAL SOURCE=http://slackware.uk/salix/x86_64/slackware-15.0/extra/:OFFICIAL SOURCE=http://slackware.uk/salix/x86_64/15.0/:PREFERRED SOURCE=http://slackware.uk/salix/x86_64/extra-15.0/:OFFICIALslapt-srcrc Also edit your /etc/slapt-get/slapt-srcrc file to point to 15.0 instead of 14.2:\nBUILDDIR=/usr/src/slapt-src PKGEXT=txz SOURCE=http://slackware.uk/salix/slkbuild/15.0/ SOURCE=http://slackware.uk/salix/sbo/15.0/Switch to root user Every command listed below should be executed with root privileges. So run:\nsudo suor alternatively, if you have the root user enabled:\nsuto open a root terminal.\nChanging your mirrors Feel free to try other [[Repository mirrors|repositoriy mirrors]] that might be faster for you. N.B: It is perfectly safe to stop the process while a package is in the process of being downloaded. On resume/restart, the download starts off where it last left. But, do not stop the process, if a package is in the process of being installed.\nAfter you make the changes, run:\nslapt-get -uslapt-src Although slapt-src has nothing to do with the upgrade process itself, better make sure its repos are pointing to 15.0 so that they work correctly after the installation. Open your /etc/slapt-get/slapt-srcrc and change the SOURCE lines to these ones:\nSOURCE=http://slackware.uk/salix/slkbuild/15.0/ SOURCE=http://slackware.uk/salix/sbo/15.0/Upgrade base package manager tools Upgrade pkgtools and spkg first as a newer version is needed for proper installation of several packages:\nslapt-get -i pkgtools spkg aaa_baseUpgrading packages Open a root terminal again first:\nsudo suNow you need to upgrade glibc and related packages:\nslapt-get -i glibc glibc-zoneinfo glibc-i18n aaa_glibc-solibsThen upgrade slapt-get itself (along with its dependencies):\nslapt-get -i aaa_libraries openssl curl libunistring slapt-getFix some missing symlinks. On 64 bit systems run:\nln -sf /lib64/libssl.so.1.1 /lib64/libssl.so.1 ln -sf /lib64/libcrypto.so.1.1 /lib64/libcrypto.so.1 ln -sf /usr/lib64/libldap-2.4.so.2.11.7 /usr/lib64/libldap-2.4.so.2 ln -sf /usr/lib64/liblber-2.4.so.2.11.7 /usr/lib64/liblber-2.4.so.2and on 32-bit systems run:\nln -sf /lib/libssl.so.1.1 /lib/libssl.so.1 ln -sf /lib/libcrypto.so.1.1 /lib/libcrypto.so.1 ln -sf /usr/lib/libldap-2.4.so.2.11.7 /usr/lib/libldap-2.4.so.2 ln -sf /usr/lib/liblber-2.4.so.2.11.7 /usr/lib/liblber-2.4.so.2Install basic system packages. On 64-bit systems, run:\nslapt-get --install-set slackware64/aand on 32-bit systems, run:\nslapt-get --install-set slackware/aYou’ll need to create some symlink again… On 64-bit systems:\nln -sf /lib64/libssl.so.1.1 /lib64/libssl.so.1 ln -sf /lib64/libcrypto.so.1.1 /lib64/libcrypto.so.1and on 32-bit systems:\nln -sf /lib/libssl.so.1.1 /lib/libssl.so.1 ln -sf /lib/libcrypto.so.1.1 /lib/libcrypto.so.1GDM has been replaced by lightdm in the default installation, so if you want to do that, run:\nslapt-get -i lightdm lightdm-gtk-greeter lightdm-gtk-greeter-settings spkg -d gdmotherwise gdm will be upgraded later and pull almost all of GNOME with it…\nInstall some necessary packages that have been renamed:\nslapt-get -i man-db python2And some that are required for the system to be working properly:\nslapt-get -i salix-polkit-settings polkit-gnome mozjs78And then upgrade all other packages to their new versions:\nslapt-get --upgradeDO NOT use:\nslapt-get --dist-upgradein any case. Although it might seem to be the best option for upgrading to a newer release, it really isn’t.\nUpgrading the kernel Lets upgrade the kernel packages next.\nRun:\nls /var/log/packages/kernel*to see which kernel packages you have installed and do a slapt-get -i for each one of them. (Do not include the package version in ).\nYou will also need to upgrade your lilo, elilo or grub packages at this point. So, for example:\nslapt-get -i eliloIf you have switched to the kernel-generic package instead of the default kernel-huge package, don’t forget to recreate the initrd.gz file which will be needed for booting you upgraded system. If you’re still using the default kernel-huge package, an initrd is not needed anyway and you needn’t be concerned about it.\nAfter upgrading the packages, don’t forget to edit your /etc/lilo.conf file accordingly and run:\nlilo -vto inform the bootloader about the kernel upgrade. If there is no /etc/lilo.conf file, just run:\nliloconfigOn similar note, users running multi-boot systems on GRUB2 must log into the distro that controls the bootloader and re-run\nupdate-grubto inform the bootloader about the kernel upgrade.\nFor those using elilo, you need to simply run\neliloconfigIf you are using the generic kernel, also copy the initrd to appropriate directory in the ESP, for example:\ncp /boot/vmlinuz /boot/efi/EFI/Salix-Xfce-14.2/vmlinuz cp /boot/initrd.gz /boot/efi/EFI/Salix-Xfce-14.2/initrdObsolete packages Some packages have been obsoleted and should be removed. Some have been replaced by new packages. You can remove all obsolete packages automatically with:\nslapt-get --remove-obsolete --removeCareful, because this will also remove all personal packages that you might have installed, if any. It will also remove any packages that used to be part of the Slackware or Salix repos in 14.2, but are not anymore in 15.0. Take a careful look at the list of packages to be removed and if you recognise anything that you want to keep, make a note. It might have been renamed to something slightly different. And it’s never a bad idea to have a look at the Slackware CHANGES_AND_HINTS.TXT file:\nChanges and Hints File for i486 Changes and Hints File for x864_64 Update caches You’ll also need to run this command:\nupdate-allThis updates icon caches, font indexes, desktop and mime databases, pango files, glib schemas etc. You’ll need to run this, or you’ll probably won’t be able to start a graphical environment and even if you do, you’ll probably see garbage instead of readable characters.\nConfiguration files After doing all the upgrades, run:\ndotnewto accept or reject new configuration files. Make sure that you DO NOT replace your /etc/passwd, /etc/shadow or /etc/group files. If you do, you will lose all users/groups/passwords you have in your system. However, even if you do, you can get the old files back, they will be kept in the same locations, with an .orig suffix.\nIf you are starting your system in init 3 (console), instead of init 4 (graphics) and you start the GUI by running ‘startx’, you’d better refresh the xinitrc file in your home directory by running (while in init 3):\nxwmconfigand selecting your preferred Desktop Environment.\nEdit /etc/slackware-version file to fill in:\nSlackware 15.0This is not required but this is used by some apps to show your version (for example grub).\nOptional packages There are several new packages in 15.0 that you might care about or not.\nYou may want to use flatpak for some of your software needs:\nslapt-get -i flatpak flatpak-toolsAnd if you want your system to look like the default in 15.0:\nslapt-get -i qogir-icon-theme salix-gtk-theme salix-xfwm4-theme(and change the respective settings in Xfce)\nAnd if you want to get rid of annoying Client Side Decorations in GTK+3 applications:\nslapt-get -i gtk3-nocsd",
    "description": "Preparing for the upgrade You first need to change the default repositories to the ones for Slackware and Salix 15.0. Open file /etc/slapt-get/slapt-getrc and change all “14.2” instances to “15.0”. Also make sure the Slackware repositories have an OFFICIAL priority. Example setups are shown below:\ni486 architecture SOURCE=http://slackware.uk/salix/i486/slackware-15.0/:OFFICIAL SOURCE=http://slackware.uk/salix/i486/slackware-15.0/extra/:OFFICIAL SOURCE=http://slackware.uk/salix/i486/15.0/:PREFERRED SOURCE=http://slackware.uk/salix/i486/extra-15.0/:OFFICIALx86_64 architecture SOURCE=http://slackware.uk/salix/x86_64/slackware-15.0/:OFFICIAL SOURCE=http://slackware.uk/salix/x86_64/slackware-15.0/extra/:OFFICIAL SOURCE=http://slackware.uk/salix/x86_64/15.0/:PREFERRED SOURCE=http://slackware.uk/salix/x86_64/extra-15.0/:OFFICIALslapt-srcrc Also edit your /etc/slapt-get/slapt-srcrc file to point to 15.0 instead of 14.2:\nBUILDDIR=/usr/src/slapt-src PKGEXT=txz SOURCE=http://slackware.",
    "tags": [],
    "title": "How to Upgrade Salix 14.2 to 15.0",
    "uri": "/user/upgrading/14.2-to-15.0/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "Salix 15.0 comes with Xfce 4.16 by default. Xfce 4.18 was released a few months after Salix 15.0 was released and we added an extra repository for it soon after.\nSo, if you want to upgrade your Xfce to version 4.18, all you have to do is add that repository to your slapt-get package manager configuration in the /etc/slapt-get/slapt-getrc file.\nFor 64-bit systems, you can add this line:\nSOURCE=https://download.salixos.org/x86_64/xfce4.18-15.0/:PREFERREDwhile for 32-bit systems, you can add this line:\nSOURCE=https://download.salixos.org/i486/xfce4.18-15.0/:PREFERREDand then just upgrade your system:\nsudo slapt-get --update sudo slapt-get --upgradeYou’ll probably want to log out of Xfce and back in after that. You will then be greeted with the shiny new Xfce 4.18 environment!",
    "description": "Salix 15.0 comes with Xfce 4.16 by default. Xfce 4.18 was released a few months after Salix 15.0 was released and we added an extra repository for it soon after.\nSo, if you want to upgrade your Xfce to version 4.18, all you have to do is add that repository to your slapt-get package manager configuration in the /etc/slapt-get/slapt-getrc file.\nFor 64-bit systems, you can add this line:\nSOURCE=https://download.salixos.org/x86_64/xfce4.18-15.0/:PREFERREDwhile for 32-bit systems, you can add this line:",
    "tags": [],
    "title": "How Do I Upgrade to Xfce 4.18?",
    "uri": "/faq/upgrade-xfce-to-4.18/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "Salix 15.0 comes with Xfce 4.16 by default. Xfce 4.20 was released a few days before Christmas 2024 and a new dedicated repository for it was added shortly after.\nSo, if you want to upgrade your Xfce to version 4.20, all you have to do is add that repository to your slapt-get package manager configuration in the /etc/slapt-get/slapt-getrc file.\nFor 64-bit systems, you can add this line:\nSOURCE=https://download.salixos.org/x86_64/xfce4.20-15.0/:PREFERREDwhile for 32-bit systems, you can add this line:\nSOURCE=https://download.salixos.org/i486/xfce4.20-15.0/:PREFERREDand then just upgrade your system:\nsudo slapt-get --update sudo slapt-get --upgradeYou’ll probably want to log out of Xfce and back in after that. You will then be greeted with the shiny new Xfce 4.20 environment!\nNOTE: If you have already added Xfce 4.18 to your system, don’t forget to remove the respective lines for it from your package manager configuration.",
    "description": "Salix 15.0 comes with Xfce 4.16 by default. Xfce 4.20 was released a few days before Christmas 2024 and a new dedicated repository for it was added shortly after.\nSo, if you want to upgrade your Xfce to version 4.20, all you have to do is add that repository to your slapt-get package manager configuration in the /etc/slapt-get/slapt-getrc file.\nFor 64-bit systems, you can add this line:\nSOURCE=https://download.salixos.org/x86_64/xfce4.20-15.0/:PREFERREDwhile for 32-bit systems, you can add this line:",
    "tags": [],
    "title": "How Do I Upgrade to Xfce 4.20?",
    "uri": "/faq/upgrade-xfce-to-4.20/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "It is very easy to create a video DVD out of your existing video files, using only command line tools.\nUniversal solution using ffmpeg The original video files can be in any format that ffmpeg supports, so that includes just about everything.\nThe tools you will need for this are ffmpeg and dvdauthor, so make sure you have them first (run as root):\nslapt-get -i ffmpeg dvdauthorUsing ffmpeg you can convert any video file to an mpg file, that dvdauthor can use later:\nffmpeg -i video.avi -aspect 16:9 -target pal-dvd dvd.mpgYou might want to change the aspect ratio to 4:3 or the target to ntsc-dvd, depending on your preferences and region. If you need to define video bitrate use the -b bitrate option:\nffmpeg -i video.avi -aspect 16:9 -target pal-dvd -b 1800000 dvd.mpgI’m not sure what units are used but the above example gives bitrate ca. 2300kbits/s which is usually enough for typical avi. Bigger bitrate gives better quality but a larger file. Just test the output and adjust the bitrate according to your needs.\nNow add the mpg file to your project using dvdauthor:\ndvdauthor -o dvd/ -t dvd.mpgYou can convert and add any number of files this way. After you’ve added all of them, run:\nexport VIDEO_FORMAT=PAL dvdauthor -o dvd/ -TYou might want to set VIDEO_FORMAT=NTSC instead.\nAnd then you can create an iso with mkisofs:\nmkisofs -dvd-video -o dvd.iso dvd/which you can burn to a DVD disc with any DVD burning software. cdrecord from the command line will do just fine.\nAdvanced usage of dvdauthor One can generate an XML file in order to define loops, pauses or create chapters, once the file is ready the usage is as follows:\nexport VIDEO_FORMAT=PAL dvdauthor -x dvd.xml -o dvd/Examples of the XML are here\nMencoder as alternative to ffmpeg If ffmpeg fails to convert properly one can use mencoder (PAL version example)\nmencoder -oac lavc -ovc lavc -of mpeg -mpegopts format=dvd \\ -vf scale=720:576,harddup -srate 48000 -af lavcresample=48000 \\ -lavcopts vcodec=mpeg2video:vrc_buf_size=1835:vrc_maxrate=9800:vbitrate=2400:keyint=15:aspect=16/9:acodec=ac3:abitrate=192 \\ -ofps 25 -o output-filename source-filenameWhat can be adjusted here is:\n#vbitrate - up to 9800 (the bigger bitrate the better quality but the larger the file) #aspect - 16/9 or 4/3Detailed description of DVD authoring with mencoder\none can use all filters available for mplayer, i.e. deinterlace (several methods for this) by modifying the -vf section :\n-vf pullup,softskip,scale=720:576,harddupanother method\n-vf pp=fd,scale=720:576,harddup one can crop the image by modifying the line\n-vf crop=720:470:0:50,scale=720:576,harddupMplayer manual gives detailed description of available filters The usage may not be very straightforward but once learnt allows many operations on the image and sound.",
    "description": "It is very easy to create a video DVD out of your existing video files, using only command line tools.\nUniversal solution using ffmpeg The original video files can be in any format that ffmpeg supports, so that includes just about everything.\nThe tools you will need for this are ffmpeg and dvdauthor, so make sure you have them first (run as root):\nslapt-get -i ffmpeg dvdauthorUsing ffmpeg you can convert any video file to an mpg file, that dvdauthor can use later:",
    "tags": [],
    "title": "How to Create a Video DVD from the CLI",
    "uri": "/user/how-to-create-a-video-dvd-from-the-cli/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e User Documentation",
    "content": "If you want to access usb devices in a guest OS running in VirtualBox PUEL, you will have to:\nEdit your /etc/rc.d/rc.S file in the host OS. Find the line that reads: /sbin/mount -v usbfs /proc/bus/usb -t usbfsand change it to:\n/sbin/mount -v usbfs /proc/bus/usb -t usbfs -o devgid=10,devmode=0664 Add your user to the wheel group. You need to remount /proc/bus/usb. A reboot will do it too. In VirtualBox, select the virtual machine you want to use and hit the settings button. Go to the USB page and make sure you have the Enable USB controller checkbox selected. If you want support for USB 2.0 check the Enable USB 2.0 checkbox too. In the same page, add a filter for the device you want to use. Easier if you already have your device connected and use the Add filter from device button. You should be able to access your USB device in your guest OS now. Be aware that the device will be inaccessible to your host OS when your guest OS is using it.",
    "description": "If you want to access usb devices in a guest OS running in VirtualBox PUEL, you will have to:\nEdit your /etc/rc.d/rc.S file in the host OS. Find the line that reads: /sbin/mount -v usbfs /proc/bus/usb -t usbfsand change it to:\n/sbin/mount -v usbfs /proc/bus/usb -t usbfs -o devgid=10,devmode=0664 Add your user to the wheel group. You need to remount /proc/bus/usb. A reboot will do it too. In VirtualBox, select the virtual machine you want to use and hit the settings button.",
    "tags": [],
    "title": "How to Access Host USB Devices in a Guest OS Running in VirtualBox PUEL",
    "uri": "/user/virtualbox-host-devices/"
  },
  {
    "breadcrumb": "Salix Documentation \u003e FAQ",
    "content": "The initial development team did know each other from other projects and were good friends. They enjoyed working together, and decided to start their own Slackware based distribution since what they had in mind (expand on Slackware ease of use while staying fully compatible with it) was not really implemented elsewhere. This was the birth of Salix.",
    "description": "The initial development team did know each other from other projects and were good friends. They enjoyed working together, and decided to start their own Slackware based distribution since what they had in mind (expand on Slackware ease of use while staying fully compatible with it) was not really implemented elsewhere. This was the birth of Salix.",
    "tags": [],
    "title": "Why Was Salix Created?",
    "uri": "/faq/why-was-salix-created/"
  }
]
